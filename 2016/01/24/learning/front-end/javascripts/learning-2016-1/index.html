<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 2016前端学习（一） · TuzK1ss' Home</title><meta name="description" content="2016前端学习（一） - Tuzk1ss"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/tuzkiss" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/resume.html" target="_self" class="nav-list-link">RESUME</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">2016前端学习（一）</h1><div class="post-info"><span class="post-date">Jan 24, 2016</span><span class="post-tag">#Javascript</span></div><div class="post-content"><p>之前说了那么多雄心壮志的话，包括喝了浓浓的鸡汤，总要做点什么咯？是吧，没有人可以动动嘴皮子或者码点字就去改变世界的（特定的人除外）。so， 向着前端架构师的方向，有距离不可怕，可怕的是想要前进的渴望和信仰。</p>
<p>会慢慢总结一些关于前端学习方面的知识，同时也要跟上看书的节奏。<br>首先先回顾下这些呗，听说是某个面试官leader出的题：js 数据类型以及判断，原型和继承，基于闭包实现唯一生成id，跨域，jsonp 具体实现代码，dom事件和自定义事件系统，前端路由，具体组件api设计和开发；css 常用布局属性，盒模型相关，position，sticky 效果，flex 布局。</p>
<a id="more"></a>
<h2 id="一、JS数据类型已经判断"><a href="#一、JS数据类型已经判断" class="headerlink" title="一、JS数据类型已经判断"></a>一、JS数据类型已经判断</h2><p>javascript中的数据类型主要分为以下几种：</p>
<p><strong>1、Number</strong><br><strong>2、String</strong><br><strong>3、Boolean</strong><br><strong>4、Null</strong><br><strong>5、Undefined</strong><br><strong>6、Object</strong></p>
<p>前五种是JS的基本类型，最后一种Object 包括几种特殊的类型，包括有Function, Array等等。</p>
<p>首先先回顾一下判断类型的几种方法：</p>
<p>1、typeof   // 直接判断类型</p>
<p>2、instance  // 判断变量是否从某个对象中构造器来？</p>
<p>3、Object.prototype.toString.call() // 使用对象原型链上的方法</p>
<h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><p>首先定义一些常用的变量，例如下面 并且输入它们的typeof的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var i = 233;</div><div class="line">var s = &apos;string&apos;;</div><div class="line">var b = true;</div><div class="line">var n = null;</div><div class="line">var u;</div><div class="line">var o = new Object();</div><div class="line"></div><div class="line">var w = new RegExp();</div><div class="line">var x = [];</div><div class="line">var y = &#123;&#125;;</div><div class="line">var z = function () &#123;&#125;;</div></pre></td></tr></table></figure>
<p>输入上面各个值的typeof</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">console.log(typeof i);  // number</div><div class="line">console.log(typeof s); // string</div><div class="line">console.log(typeof b); //boolean</div><div class="line">console.log(typeof n); // object </div><div class="line">console.log(typeof u); // undefined</div><div class="line">console.log(typeof o); // object</div><div class="line"></div><div class="line">console.log(typeof w); // object</div><div class="line">console.log(typeof x); // object</div><div class="line">console.log(typeof y); // object</div><div class="line">console.log(typeof z); // function</div></pre></td></tr></table></figure>
<p>上述代码中可以看到，基本类型中，除了null之外都会返回正常的类型判断。至于typeof null 为什么会等于object? 1995年JS诞生时，根本没把null当作数据类型，而是Object的一种特殊值。下面是当年C源码，其中完全没考虑null。这就是typeof null === object的根本原因。。。<br><img src="https://cloud.githubusercontent.com/assets/5539512/12551894/e23dcbac-c3a8-11e5-807e-81bd0aed2ca5.png" alt="image"></p>
<p><strong>那么简单的number，string， boolean， undefined可以直接使用typeof 进行判断。</strong></p>
<p><strong>而下面其中特殊的对象类型function使用typeof检测也可以返回正确的值</strong></p>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>如果变量是给定引用类型的实例时，instanceof操作符就会返回ture。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var instanceofVariable = function (variable, type) &#123;</div><div class="line">    &quot;use strict&quot;;</div><div class="line"></div><div class="line">    console.log(variable instanceof type);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">instanceofVariable(i, Number);   // false</div><div class="line">instanceofVariable(s, String);     // false</div><div class="line">instanceofVariable(b, Boolean); // false</div><div class="line">instanceofVariable(n, Object);   // false</div><div class="line">// instanceofVariable(u, ...); </div><div class="line">instanceofVariable(o, Object);   // true</div><div class="line"></div><div class="line">instanceofVariable(w, RegExp); // true</div><div class="line">instanceofVariable(x, Array);     // true</div><div class="line">instanceofVariable(y, Object);   // true</div><div class="line">instanceofVariable(z, Object);   // true</div></pre></td></tr></table></figure>
<p><strong>上述代码的结果可见，instanceof只能用于检测对象类型的数据, 然后null instanceof Object === false</strong></p>
<h4 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call"></a>Object.prototype.toString.call</h4><p>那么问题来了？ 如果判断一个对象类型呢？不可能去每一种对象类型都去判断一下，所以我们使用Object.prototype.toString.call， 已经每个对象的原型链末端均为Object， 也就是说每个对象都是Obect的实例，使用可以调用Object原型链上的toString方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var toStringCall = function (variable) &#123;</div><div class="line">    &quot;use strict&quot;;</div><div class="line"></div><div class="line">    console.log(Object.prototype.toString.call(variable));</div><div class="line">&#125;;</div><div class="line"></div><div class="line">toStringCall(i);  // [object Number]</div><div class="line">toStringCall(s);  // [object String]</div><div class="line">toStringCall(b);  // [object Boolean]</div><div class="line">toStringCall(n);  // [object Null]</div><div class="line">toStringCall(u);  // [object Undefined]</div><div class="line">toStringCall(o);  // [object Object]</div><div class="line"></div><div class="line">toStringCall(w);  // [object RegExp]</div><div class="line">toStringCall(x);  // [object Array]</div><div class="line">toStringCall(y);  // [object Object]</div><div class="line">toStringCall(z);  // [object Function]</div></pre></td></tr></table></figure>
<p><strong>WOW</strong></p>
<p><strong>使用Object.prototype.toString.call返回了所以的正确结果咯， 然后为什么基本类型也会返回？</strong></p>
<p>在ES5中Object.prototype.toString规范如下</p>
<blockquote>
<p>15.2.4.2 Object.prototype.toString ( )<br>在toString方法被调用时,会执行下面的操作步骤:<br>1、如果this的值为undefined,则返回”[object Undefined]”.<br>2、如果this的值为null,则返回”[object Null]”.<br>3、让O成为调用ToObject(this)的结果.<br>4、让class成为O的内部属性[[Class]]的值.<br>5、返回三个字符串”[object “, class, 以及 “]”连接后的新字符串.</p>
<h3 id="总结-："><a href="#总结-：" class="headerlink" title="总结 ："></a>总结 ：</h3></blockquote>
<p>1、那么对于基本类型的判断除null以外可以使用typeof<br>2、对于特性的对象可以使用instanceof判断<br>3、对于未知的对象类型，使用Object.prototype.toString判断即可。</p>
<p>不过貌似ES6中能有新的类型，到时候在添上。</p>
<p>PS，上述中遗漏了Date类型的对象，可以自行添加</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/01/25/learning/front-end/javascripts/learning-2016-2/" class="prev">PREV</a><a href="/2016/01/07/project/website/10years/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'tuzkiss';
var disqus_identifier = '2016/01/24/learning/front-end/javascripts/learning-2016-1/';
var disqus_title = '2016前端学习（一）';
var disqus_url = 'http://www.tuzkiss.com/2016/01/24/learning/front-end/javascripts/learning-2016-1/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//tuzkiss.disqus.com/count.js" async></script><div class="copyright"><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/tuzkiss/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p><p>© 2015 - 2017 <a href="http://www.tuzkiss.com">Tuzk1ss</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>