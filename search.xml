<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[macOS Nginx HTTPS 环境配置]]></title>
    <url>%2F2020%2F08%2F28%2FMac%2Fnginx-HTTPS-configuration%2F</url>
    <content type="text"><![CDATA[前置阅读: macOS 下 Nginx 安装及设置 近期在部分开发场景中，需要使用的 HTTPS 环境，故研究了下 macOS 下 Nginx HTTPS 环境配置。( HTTPS 相关知识可自行了解 ) 创建自定义 SSL 证书之前在服务器上一直使用 Let’s Encrypt 的 Certbot 脚本一键安装，但是发现本地并无法正确申请证书和使用。在搜索相关教程和对比之后，发现可以通过 OpenSSL 生成证书或直接使用 mkcert 简易生成证书。 本文主要针对 mkcert 如何创建证书及使用。 安装使用 macOS 上的 Package Manager - HomeBrew 来安装 mkcert。 12$ brew install mkcert$ brew install nss # if you use Firefox 创建根证书创建根证书 CA ( Certificate Authority，即证书颁发机构 )，可以运行以下命令 123456$ mkcert -install# 成功安装后输出# Using the local CA at "/Users/Tuzkiss/Library/Application Support/mkcert" ✨# The local CA is now installed in the system trust store! ⚡️# The local CA is already installed in the Firefox trust store! 👍 安装后使用 Keychain Access App 查看安装的证书，点击具体证书可以查看更详细信息： 创建自签名证书例如需要针对 tuzkiss.com 、localhost 等域名生成自签名证书，则可以运行以下命令： 12345678910$ mkcert tuzkiss.com localhost 127.0.0.1# 成功安装后输出# Using the local CA at "/Users/Tuzkiss/Library/Application Support/mkcert" ✨# Created a new certificate valid for the following names 📜# - "tuzkiss.com"# - "localhost"# - "127.0.0.1"# The certificate is at "./tuzkiss.com+2.pem" and the key at "./tuzkiss.com+2-key.pem" ✅ 成功创建之后，会在该目录下生成如下两个文件： 证书 tuzkiss.com+2.pem 私钥 tuzkiss.com+2-key.pem 你可以手动跟改这两个文件名，例如: 12tuzkiss.com+2.pem -&gt; Tuzkiss-SSL.pemtuzkiss.com+2-key.pem -&gt; Tuzkiss-SSL-Key.pem 或者可以直接通过 mkcert 中命令参数创建: 1$ mkcert -cert-file Tuzkiss-SSL.pem -key-file Tuzkiss-SSL-Key.pem tuzkiss.com localhost 127.0.0.1 最终都会生成如下两个文件: 至此，自定义 SSL 证书均已创建完毕。 更多 mkcert 详细使用可查看：https://github.com/FiloSottile/mkcert Ngixn Server 配置将上述创建的 SSL 证书和私钥放到合适的位置（ 凭个人喜好 ），然后编辑 Nginx 配置文件： 12345$ vi /usr/local/etc/nginx/nginx.conf# or $ code /usr/local/etc/nginx/nginx.conf 在 nginx.conf 中的 http 字段中配置 server，例如:（ 需要根据实际情况调整 ssl_certificate、ssl_certificate_key、root 等字段 ） 12345678910111213141516171819202122232425server &#123; # 同时监听 80、443 端口，并设置 server name 为 tuzkiss.com、localhost listen 80; listen 443 ssl; server_name tuzkiss.com localhost; # 设置 SSL 证书和私钥地址 ssl_certificate /Users/Tuzkiss/CodeProjects/Tuzkiss-SSL.pem; ssl_certificate_key /Users/Tuzkiss/CodeProjects/Tuzkiss-SSL-key.pem; # SSL 会话配置 ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; # SSL 协议、加密配置 ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; # 服务器地址等配置 location / &#123; root /Users/Tuzkiss/CodeProjects; index index.html index.htm; &#125;&#125; 修改完成后需运行以下命令来重启 Nginx 服务器，保证设置的配置生效: 1$ sudo nginx -s reload 重启之后可以通过访问上述证书中设定任意 HTTPS 地址验证： https://127.0.0.1 https://localhost https://tuzkiss.com 当然也可以通过 Chrome DevTools 中的 Security Overview 查看当前信息： 至此，可以愉快的使用 HTTPS 本地服务器进行开发、调试了～ 🎉 其他设备访问例如想在 iOS Safari 上访问该域名，则可以通过 iOS 上代理软件 ( Surge / Quantumult X 等) 将 tuzkiss.com 设置本地 IP Host，参考配置如下： 12345678# Surge iOS[Host]tuzkiss.com = 192.168.123.204# Quantumult X[dns]address=/tuzkiss.com/192.168.123.204 然后通过手动信任即可访问: Webpack devServer 使用同时生成的证书也可以配合 Webpack devServer 使用，例如设置 webpack.config.js 中配置：( 需要根据实际情况调整 key、cert、ca 参数 ) 1234567891011121314151617181920212223module.exports = &#123; //... devServer: &#123; // HTTPS 相关设置 https: true, key: fs.readFileSync('/Users/Tuzkiss/CodeProjects/Tuzkiss-SSL-Key.pem'), cert: fs.readFileSync('/Users/Tuzkiss/CodeProjects/Tuzkiss-SSL.pem'), ca: fs.readFileSync('/Users/Tuzkiss/Library/Application Support/mkcert/rootCA.pem'), // 基础设置，可根据实际情况调整 contentBase: path.join(__dirname, './demo'), publicPath: '/dev/', host: '127.0.0.1', compress: true, port: 8080, hot: true, allowedHosts: [ 'tuzkiss.com' ], open: true, openPage: 'https://tuzkiss.com' &#125;&#125;; 如上设置之后，运行 webpack-dev-server 就可以愉快的直接使用 HTTPS 环境了～ 更多 Webpack devServer HTTPS 详细使用可查看:https://webpack.js.org/configuration/dev-server/#devserverhttps That’s all, enjoy your life ~ 😏]]></content>
      <tags>
        <tag>Mac</tag>
        <tag>macOS</tag>
        <tag>Nginx</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS Code 设置与技巧]]></title>
    <url>%2F2019%2F07%2F16%2FMac%2FVS-Code-configuration%2F</url>
    <content type="text"><![CDATA[年中在 Apple 更新了 MacBook Pro 2019 之后，终于还是没忍住下单了 15 寸次顶配，于是手中的 MacBook Pro 13-inch Early 2015 理所当然的退休了。 之前一直使用 WebStorm 作为主力 IDE，但是鉴于之前 MacBook Pro 2015 性能有所欠缺，在后期的使用中存在些长时间使用卡顿的现象，所以准备在新 MacBook Pro 2019 上使用 VS Code 来作为新的 IDE。（ 当然这一块选择上也各有所爱，不必强求。） 俗话说得好，工欲善其事，必先利其器。所以，在这总结并记录下在使用 VS Code 编辑器中的一些设置与技巧。 相关环境及版本地址:macOS Mojave 10.14.5 (18F132)Visual Studio Code 1.36.1 (1.36.1)Alfred 4 4.0.3 启动项目平时可能经常需要在以下场景下启动 VS Code: 在 VS Code 中手动打开项目， File → Open 在 Terminal 中启动 VS Code 打开当前项目或者指定项目 在 Finder 中选中项目文件夹，启动 VS Code 中打开该项目 通过搜索指定项目，并启动 VS Code 打开指定项目 手动打开最基础也是最简单的打开方式。（ 但是个人觉得有点麻烦，操作步骤有点多 在 VS Code 左上角 File → Open → Select Project 在 VS Code 中通过快捷键 ⌘ + O → Select Project 在 Terminal 中打开项目有时候在 Terminal 中操作时，会遇到一些可能需要打开项目的需要，所以如果能直接通过 Terminal 打开项目，就能减少手动打开的操作步骤。 // 启动 VS Code 并打开当前目录项目 $ code . // 启动 VS Code 并打开 project-name 文件名的项目 $ code project-name 具体可以查看 VS Code 官网中相关链接： https://code.visualstudio.com/docs/editor/command-line 在 Finder 中打开项目 （）全局搜索并打开项目 （）To Be Continued…]]></content>
      <tags>
        <tag>Mac</tag>
        <tag>macOS</tag>
        <tag>VS Code</tag>
        <tag>Visual Studio Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS Nginx 安装及设置]]></title>
    <url>%2F2019%2F07%2F14%2FMac%2Fnginx-configuration%2F</url>
    <content type="text"><![CDATA[安装 Nginx使用 macOS 上的 Package Manager - HomeBrew 来安装 Nginx。 如果还未安装 HomeBrew, 可以自行登录官网安装。https://brew.sh/或者在 Terminal 运行如下脚本: /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 正式安装 Nginx 在 Terminal 中运行如下命令: 1$ brew install nginx 等待安装完成之后，可以通过 $ nginx -h 来查看可使用命令，如下图： 运行以下命令开启 Nginx 服务 1$ nginx 此时打开 http://localhost/ 或 http://127.0.0.1 查看是否 Nginx 是否正常运行。 nginx -s 中参数说明: 1234stop — fast shutdownquit — graceful shutdownreload — reloading the configuration filereopen — reopening the log files 如果是其他 Linux 系统，安装类似。 修改 Nginx 配置安装完成之后，可以设置 Nginx 配置来指定默认 Root 文件夹 1$ vim /usr/local/etc/nginx/nginx.conf 手动修改默认 server 中 location 中 root 地址，例如： 修改完成之后，手动重启 nginx 服务 1$ nginx -s reload 此时可以通过 localhost 或者 127.0.0.1 来验证 root 是否修改成功。 如果遇到 403 nginx 403 forbidden可以尝试使用: $ sudo chmod 755 [root directory name] 开机自启动作为开发者需要设置一些启动项，用于每次重启之后自动启动 Nginx 服务，减少重新开启的重复劳动力，那么就可以进行如下设置： 首先需要将 Nginx 服务文件添加至系统启动进程文件夹中（ 使用管理员权限运行 ） 123$ sudo cp -v /usr/local/opt/nginx/*.plist /Library/LaunchDaemons$ sudo chown root:wheel /Library/LaunchDaemons/homebrew.mxcl.nginx.plist 同时需求确保启动列表中设置 Nginx 服务状态是活跃的，例如: 12345$ sudo vim /Library/LaunchDaemons/homebrew.mxcl.nginx.plist# Ensure this is in the file:# &lt;key&gt;KeepAlive&lt;/key&gt;# &lt;true/&gt; 最后将 Nginx 服务加载到启动列表 1$ sudo launchctl load /Library/LaunchDaemons/homebrew.mxcl.nginx.plist Enjoy~]]></content>
      <tags>
        <tag>Mac</tag>
        <tag>macOS</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[东欧九天五城四国游（二）]]></title>
    <url>%2F2017%2F11%2F21%2Flife%2Ftravel-in-europe-2%2F</url>
    <content type="text"><![CDATA[现在是北京时间的2017年11月21日23:47:37，从东欧回来的第170天，拖了半年的游记，终于在今天又被我提上日程。 也许是最近有些莫名的小情绪无处诉说，所以才又想起来，写点东西好了。 到了🇩🇪柏林的第一天晚上，稍微休息了之后，就准备出去觅食。出门的第一个路口，看到一辆粉色的单车，瞬间有点少女心爆棚。让我想起那辆陪伴我度过美好岁月的死飞，也许一直莫名的对纯色的单车有好感。 之后就开始朝着人多的地方寻找，很是羡慕那种生活，下班或放学之后，还能和三两好友喝上一杯，谈谈足球，聊聊人生，抑或着其他。 简单的吃过东西之后，发现酒店附近有一家supermarket，记得当时还是有点小兴奋的，怎么说也是第一次逛资本主义的超市。后来才发现，自己已经爱上了资本主义的supermarket。零零散散的购置了些就准备去休息，需要恢复下精力来面对明天的行程。 第二天是忙碌的一天 - 柏林一日游。我们到某个景点的时候，太阳已经高高升起，而门口也坐满了人。近乎万里无云的蓝天，以及和煦的阳光，甚是想在这种草坪上躺上足足一天。 可我毕竟只是一个游客。简单的参观了周边的附属景点，附上一张看上去就是游客照的游客照 ： 累了之后去找吃的路上，遇上了附近学校刚下课的成群结队的学生们，看到年轻有活力的面孔很是感慨，年轻真好。我们在路边的长凳上坐着，乘着树荫下的阵阵清风，看着来来往往的行人和车流，甚至有点想留着资本主义的冲动。（hhhhh….想的有点多） 到了傍晚，来到了柏林大教堂，看着一群人在排队，原来今天好像有什么活动，而且马上就要开始了。那么，我们就毫不犹豫的混入其中。虽然排队的人中绝大多数都是爷爷奶奶，虽然我们中并没有一个信教，但是来都来了，不进去岂不是可惜了。 然而，当我们进去之后，才发现我们好像进错地方了。我们被分发了下面的歌本，以及教堂中已经开始陆陆续续的开始合唱起歌来。好奇心害死猫，也许就是这么来的。而且听说关门之后就要等结束才能出去，那样的话美好的晚上就泡汤了。终于考虑了良久，还是不要脸的顶着众人的目光，赶上了出去的末班车。下次遇到这种事，总觉得自己会在外面看看就好。 从大教堂出来之后，火急火燎的赶往世界驰名的柏林墙。那个见证欧洲历史和岁月痕迹的象征。走过长长的柏林墙，上面充斥各种奇奇怪怪的涂鸦，有些通俗易懂，有些不明觉厉，有些就不知道是个什么了。23333 那么，必不可少的肯定是这个最富盛名的的《兄弟之吻》。路边还坐着个美术系的妹纸，临摹着这幅画，偷瞄了几眼，好像画的还不错。可惜没把她的画和涂鸦一起入镜。 走完长长的柏林墙，在不知道是不是尽头的出现一个缺口。进去之后，尽然是一条河，以及河边或休息或散步的人群。三三两两，各自享受着这一天中最惬意的时光。 晚上21:20的柏林，却刚是柏林太阳落山的时刻。What a long day。夜还未深，却已疲惫。那么下一站，是哪里呢。 未完待续… （希望不是有生之年）]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[东欧九天五城四国游]]></title>
    <url>%2F2017%2F06%2F07%2Flife%2Ftravel-in-europe%2F</url>
    <content type="text"><![CDATA[从东欧回来的第三天，北京世界的2017年06月07日23:39:50，休息了两天，终于在今天有空静下来好好回顾下这次旅行。 世界那么大，我想去看看。 05月26日，赶着19:00准时的下班铃声，踏上了寻找欧洲人之血脉的东欧之旅。回家，整理，赶路，值机，过海关，候机…感觉自己都没有停下来过。值得欣慰的是，借小伙伴的光，去浦东国际机场的 VIP 室休息了会。 27日凌晨1:00的飞机，首站🇩🇪德国-慕尼黑， 然后转机🇩🇪德国-柏林，我们的东欧首站。 第一次在飞机上经历12小时+，从时间的漫长，到轮换各种坐姿依旧不舒服，最终在凌晨看到小伙伴都没有睡着，就拿出了东野奎午的《解忧杂货铺》。邻座的那个妹纸，从上飞机就开始脱掉鞋子开始沉睡，一直到第二天早上，然后跟不认识的隔壁妹纸夸夸其谈…真是竟然还有这些操作。 到达🇩🇪德国-柏林已是27日的中午，下了飞机，就开始寻找前往酒店的方向。也第一次感受到了万恶的资本主义。在那里，大部分人并不会讲英语，大部分公共场合标示都没有英文，也许这就是资本主义的任性吧。 用 Google Map 一查，机场大巴转地铁。然后，第一次进地铁站时一脸懵逼，沿着指示牌就直接到候车区域，么有安检，没有键盘…刚开始还怀疑资本主义坐车都不用票的咯。窃窃自喜的我们还是上了地铁。下车的时候，遇到一个应该是国人或亚裔的阿姨，告诉我们🇩🇪德国的地铁票要自助购买，自助检票的，如果被抓没票或票没检，都是要被罚款€60/人。所以，后来我们就没有逃过票，也见识了资本主义的地铁票 👇 € 2.80 ，好贵。 接着 check-in，凭着过了专八的小伙伴，顺利的入驻了。Capri by Fraser Berlin, 第一周开业的周末。 本来打算先洗漱下，然后稍微休息下，晚些再出去逛逛，看看资本主义的风景。然而，万万没想到我竟然把 iPad的落在了转机的 Lufthansa 航空上，万念俱灰的我低落的先去洗漱了。当时的我内心五味杂陈，不怎么丢东西的我，竟然在旅途开始的第一天就犯了一个巨大的 mistake 。 不过，在我洗漱的时候，小伙伴帮我打电话咨询了机场以及 Lufthansa 航空的服务中心。没想到，Lufthansa 航空竟然在短短2个小时之内，收录了我遗失的 iPad，并告知了编号，好让我们可以去领取。 终于，在忙碌了一下午之后，我的 iPad回到了我身边。感动… 中午大家约定是大约下午16:30分出去走走，但是，一直到19:30, 隔壁的2个小伙伴依旧没有醒来的迹象，也打不通任何电话… 估计是飞机上太累了吧，后来才知道，他们好像在飞机上并没有睡多少之间… 毕竟不是每个人就像我那样，颈部靠枕，眼罩，拖鞋，降噪耳机… 未完待续…]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack Workflow]]></title>
    <url>%2F2017%2F02%2F21%2Fproject%2Fbuild-tools%2Fwebpack-workflow%2F</url>
    <content type="text"><![CDATA[一、概述开发语言： HTML + Less@2.7.1 + TypeScript@1.8.10依赖项： 第三方组件flv.js + 第三方开源插件构建工具： webpack@1.13.1 目的： 编译混淆打包源码及素材，并打包合并第三方文件成单个文件。 __ 问题：__1、 如何对源码文件混淆打包，第三方文件仅打包，最终再将这两部分打包成单个文件？2、如何对源码部分进行深度混淆？3、 如何设计多种工作流适应多种开发调试环境？ __ 设想：__1、定制webpack工作流，大致如下图： ① =&gt; ③ =&gt; ④ (打包编译源码, 生成 player.js)==================== } =&gt; ③ =&gt; ⑥ (打包合并)② =&gt; ③ =&gt; ⑤ (打包合并第三方代码, 生成library.js) 2、可以考虑webpack自带的插件UglifyJS 或者 第三方Google Closure Compiler。3、可以使用在package.json 中配置npm scripts来实现多命令工作流。 二、定制工作流2.1 webpack 工作流 在项目架构设计开始，还没有正式发布 webpack2，所以一直使用的是 webpack。webpack2与webpack配置等部分会有些差异，短期不考虑迁移。后期可以考虑迁移到webapck2。如有兴趣，也可以直接查看 webpack2 官方文档。 下图简要说明了Webpack的构建作用。 webpack工作流的例如下图： 上图这样的项目结构如下图（源文件app.js, cats.js 打包生成app.bundle.js）： 配置package.json： const webpack = require(&apos;webpack&apos;); module.exports = { entry: &apos;./src/app.js&apos;, output: { path: &apos;./bin&apos;, filename: &apos;app.bundle.js&apos;, }, module: { loaders: [{ test: /\.js?$/, exclude: /node_modules/, loader: &apos;babel-loader&apos;, }] }, plugins: [ new webpack.optimize.UglifyJsPlugin({ compress: { warnings: false, }, output: { comments: false, }, }), ] }2.2 定制项目工作流__ 目标工作流： __1、编译混淆打包源码及资源，包括TypeScript, Less, images等，生成文件player.js。2、打包合并第三方组件和第三方插件，仅压缩，不做其他任何处理，生成文件library.js3、最后将player.js和library合并打包成player.min.js, 不做任何处理。 __ 初步想法：__尝试通过webpack plugins来分情况来实现工作流。 __ 遇到问题：__打包合并是通过webpack原生来实现的，并没有插件来实现编译打包之后能再次自定义打包的功能。 __ 解决方案：__那么我们可能就需要自己定制一个插件。 Webpack提供了API可以让开发者自定义开发Webpack工作流中的Plugins。地址为: http://webpack.github.io/docs/plugins.html webpack的插件工作流中总共分成这么几个步骤：图片地址:http://7xoebg.com1.z0.glb.clouddn.com/170221174303.jpeg?imageMogr2/strip 具体可以查看Taobao FED的这篇总结。 可以将自定义的事件异步绑定在某个工作流上。 __ 自定义webpack plugin __ 新建webpack.plugin.concatenate.js文件： // webpack.plugin.concatenate.js function Concatenate (options) { this.options = options; } Concatenate.prototype.apply = function (compiler) { compiler.plugin(&apos;emit&apos;, function (compilation, callback) { var _output = &apos;&apos;, _filename = &apos;&apos;; compilation.chunks.forEach(function(chunk) { // Explore each module within the chunk (built inputs): chunk.modules.forEach(function(module) { // Explore each source file path that was included into the module: }); // Explore each asset filename generated by the chunk: chunk.files.forEach(function(filename) { // Get the asset source for each file generated by the chunk: var source = compilation.assets[filename].source(); _filename = filename; _output += source + &apos;\n&apos;; }); }); var filenameArr = _filename.split(&apos;.&apos;); filenameArr.splice(filenameArr.length - 1, 0, &apos;min&apos;); _filename = filenameArr.join(&apos;.&apos;); if (this.options[&apos;name&apos;]) { _filename = this.options[&apos;name&apos;]; } if (this.options[&apos;banner&apos;]) { var _banner = this.options[&apos;banner&apos;], _bannerArr = _banner.split(&apos;\n&apos;), _comments = &apos;/*!&apos;; _bannerArr.forEach(function (_b) { _comments += &apos;\n* &apos; + _b; }); _comments += &apos;\n*/\n\n&apos;; _output = _comments + _output; } compilation.assets[_filename] = { source: function() { return _output; }, size: function() { return _output.length; } }; callback(); }.bind(this)); }; module.exports = Concatenate;使用： // webpack.config.js var Concatenate = require(&apos;./webpack.plugin.concatenate&apos;); var library = &apos;./src/library.js&apos;, player = &apos;./src/index.js&apos;; var config = { entry: { library: library, player: player }, output: { path: path.resolve(__dirname, &apos;dist&apos;), publishPath: &apos;/&apos;, filename: &apos;[name].js&apos; }, // module: ... plugins: [ // ..., new Concatenate({ name: &apos;player.min.js&apos;, banner: &apos;Copyright Tuzk1ss 2016 - 2017&apos; }) ] }输出文件例如：生成dist文件夹内文件格式如下：其中，player.min.js类似格式如下： 三、深度混淆深度混淆是指将属性名等各种可以被压缩混淆的命名都压缩。有两种解决方案：Webpack自带Webpack.Plugin.UglifyJS 或 Google Closure Complier。 简单使用之后发现，使用UglifyJS简单方便，但是当前版本（@2.7.5）无法默认识别各种原生JavaScript方法，以及定制化比较麻烦。使用Google Closure Complier虽然耗时相对UglifyJS多一些，但是对原生JavaScript方法，和自定义不压缩混淆属性比较友好… 所以考虑之后，采用Google Closure Complier。 需要新建一个自定义未压缩命名文件，例如， webpack.externs.js。 可以在这个链接 https://github.com/google/closure-compiler/tree/master/contrib/externs 找到 你在项目中使用到的第三方JavaScript类库等… 例如jQuery // webpack.externs.js // customize proterties var set, get, value, ... // jQuery proterties /** * @typedef {(Window|Document|Element|Array&lt;Element&gt;|string|jQuery| * NodeList)} */ var jQuerySelector; /** @typedef {function(...)|Array&lt;function(...)&gt;} */ var jQueryCallback; ...在webpack.config.js中配置改插件： // webpack.config.js config.plugins.push(new ClosureCompilerPlugin({ exclude: /library\.js/i, compiler: { compilation_level: &apos;ADVANCED&apos;, externs: [&apos;./webpack.externs.js&apos;] } }));四、使用NPM Script多任务处理4.1 Development Static Mode本地开发静态模式， 需要每次手动刷新页面。在package.json中”scripts”字段添加: // package.json scripts &quot;webpack&quot;: &quot;webpack &quot; // run npm run webpack4.2 Development Hot Load Mode本地开发热加载模式，自动更新页面。在package.json中”scripts”字段添加: // package.json scripts &quot;dev&quot;: &quot;webpack-dev-server&quot;, // run npm run dev4.3 Release Static Mode远程代理混淆静态模式，需要每次手动刷新页面。在package.json中”scripts”字段添加：__使用兼容类Unix和windows node环境npm插件: cross_env __ // package.json scripts &quot;release&quot;: &quot;cross-env NODE_ENV=release webpack&quot;, // run npm run release___在webpack.config.js能使用 process.env.NODE_ENV 获取到npm scripts中的变量, 例如： __ // webpack.config.js ... if (&apos;release&apos; === process.env.NODE_ENV) { // 混淆模式 } else if (&apos;publish&apos; === process.env.Node_ENV) { // 发布模式 } else { // 普通模式 } 4.4 Release Hot Load Mode远程代理混淆热加载模式。在package.json中”scripts”字段添加：__使用兼容类Unix和windows node环境npm插件: cross_env __ // package.json scripts &quot;dev-release&quot;: &quot;cross-env NODE_ENV=release webpack-dev-server&quot;, // run npm run dev-release在webpack.config.js同上, #4.5 4.5 Publish Mode发布模式。具体过程可以自己定制，需要依次运行多条npm脚本的话可以使用 &amp;&amp; 符号链接。例如: // copy 暂未定义 npm run release &amp;&amp; npm run copy具体过程比较复杂，大致为混淆打包 =&gt; 复制 =&gt; zip =&gt; 输出过程时间。 如下图： （gif 大约30s, 请耐心等待） 四、优化及改进 输出换行及颜色兼容window平台 优化源码压缩混淆时间]]></content>
      <tags>
        <tag>Build Tool</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Player Loader - Flash与HTML5播放器统一加载方案]]></title>
    <url>%2F2017%2F01%2F01%2Fproject%2Fplayer%2Fplayer-loader%2F</url>
    <content type="text"><![CDATA[一、架构背景： 页面中需要使用Flash播放器或HTML5播放器，同时播放器会与页面进行某些交互。已知调用Flash播放器的方法和HTML5播放器的方法不一致，尽量少改动页面前端代码。 设想： 建立一个第三方播放器加载容器文件，通过播放器加载容器文件来加载Flash播放器或HTML5播放器，同时暴露出部分API与页面交互。如下图： 情况如下： 1.1、初次加载，默认Flash 播放器： ① （创建实例，准备加载Flash播放器） -&gt; ②（加载并实例化Flash播放器）-&gt; ③ （成功创建，并触发回调函数） 1.2、Flash播放器切换至HTML5 播放器 如果该浏览器支持HTML5播放器，则：③（准备切换至HTML5播放器） -&gt; ①（检测该浏览器是否支持HTML5播放器，如果支持） -&gt; ④ （成功加载并实例化HTML5播放器） 如果该浏览器不支持HTML5播放器，则：（准备切换至HTML5播放器） -&gt; ①（检测该浏览器是否支持HTML5播放器，如果不支持） -&gt; ② （重新创建Flash播放器） 1.3、HTML5播放器切换至Flash播放器： ⑤（准备切换至Flash播放器） -&gt; ①（准备加载Flash播放器） -&gt; ② （成功加载Flash播放器） 1.4、再次加载时，会根据上次使用播放器类型： 若为Flash播放器，则为： ① -&gt; ② 若为HTML5播放器, 则为： ① -&gt; ④ 1.5、外部调用播放器API时，则会根据播放器类型： 若为Flash播放器，则为： ① -&gt; ② 若为HTML5播放器, 则为： ① -&gt; ④ 二、实现2.1、概述使用单例模式，创建一个名为EmbedPlayer的构造器函数，传入创建播放器所需的参数，根据用户选择实例化Flash播放器或者HTML5播放器，并绑定外部调用API接口函数。 2.2、默认配置项var config = { revision: &apos;&apos;, // 版本号, 用于记录和更新缓存 defaultType: &apos;&apos;, // 播放器默认类型 localName: &apos;&apos;, // 播放器LocalStorage Key Name typeMap: {}, // 播放器类型枚举 mapping: {}, // Feedback 弹窗隐射表 autoFeedback: {}, // 自动Feedback 弹窗 options: {}, // 播放器通用参数 flashvars: {}, // 播放器 param: {}, // Flash播放器参数 prefilter: function (options) {} // 前置过滤函数 };2.3、API接口// Construcor EmbedPlayer: function (options) {} // Portotype Method done: function () {} // 成功回调函数 loader: function () {type, callback} // 切换播放器 reload: function () {callback} // 重新载入播放器 // Static Method feedback: function () {} // 显示播放器反馈面板 loader: function (type, callback) {} // 切换播放器 reload: function (callback) {} // 重新载入播放器2.4、Examplevar player = new EmbedPlayer({ container: document.getElementById(&apos;player_container&apos;), cid: 110 });三、存在问题及优化方向3.1 目前使用单例模式，无法同时创建多个播放器实例，无法在同个页面使用多个播放器。后期可以考虑使用其他设计模式。 3.2 目前使用手动修改 Config.revision来更新版本和缓存，每次修改播放器文件需要同时修改此文件。后期考虑是否可以优化。]]></content>
      <tags>
        <tag>Javascript</tag>
        <tag>Player</tag>
        <tag>BILIBILI</tag>
        <tag>Player-Loader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016前端学习（四）]]></title>
    <url>%2F2016%2F01%2F27%2Flearning%2Ffront-end%2Fjavascripts%2Flearning-2016-4%2F</url>
    <content type="text"><![CDATA[跨域写过Ajax一般都知道，通过XHR实现Ajax通信的一个主要限制就是跨域安全策略 当然，有些开发中必然少不了跨域开发的问题，所以就出现了CORS 1、CORSCORS （Cross-orgin Resource Sharing） 跨域资源共享。 CORS的基本思想是，使用自定义的HTTP头部信息让浏览器跟服务器沟通，从而决定请求或相应的成功或失败。 有那么两个跨域可能造成的危害 CSRF (Cross-site Resource Forgery) 跨站点请求伪造XSS (Cross-site Scripting) 跨站点脚本 当然，目前主流的浏览器都支持XHR的CORS，但是需要服务端的配合修改。那么，机智的前端们总会想出写完美解决的方法，例如JSONP。 2、JSONPJSONP （JSON with padding） 填充式JSON 或者说参数式JSON。 JSONP是目前用的比较广泛的跨域技术。 JSONP的原理是动态添加script标签，并处理返回的json数据。例如 ： 123456789101112131415161718192021222324/** * jsonp function * * @param &#123;string&#125; url * @param &#123;string&#125; callback */function jsonp (url, callback) &#123; &quot;use strict&quot;; var _script = document.createElement(&apos;script&apos;), _head = document.getElementsByTagName(&apos;head&apos;)[0]; _script.src = url + &apos;?callback=&apos; + callback; _head.appendChild(_script);&#125;jsonp(&apos;http://pr.10years.me/webschool&apos;, &apos;jsonpCallback&apos;);window.jsonpCallback = function (res) &#123; &quot;use strict&quot;; // do something console.log(res);&#125;; 注意点： 传入的callback为string类型。。 当然， JSONP也存在不足：1、因为JSONP是从不同域加载，所以如果不是信任的站点可能存在不安全的现象2、要确定JSONP请求是否失败并不容易（虽然说HTML5有了script的onerror属性，但是目前浏览器支持情况并不是很好。貌似只能通过很恶心的轮训来判断是否加载成功。） 3、CometComet 服务器推送， 分为长轮询 和流。 4、Web Scokets… 更多请自行Google了解]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016前端学习（三）]]></title>
    <url>%2F2016%2F01%2F26%2Flearning%2Ffront-end%2Fjavascripts%2Flearning-2016-3%2F</url>
    <content type="text"><![CDATA[三、闭包生成唯一ID12345678var createUniqueId = function () &#123; &quot;use strict&quot;; var _id = 0; return function () &#123; return _id ++; &#125;;&#125;; 123456var createId = createUniqueId();createId(); // 0createId(); // 1createId(); // 2createId(); // 3 上述代码挺简单的，但是要理解闭包原理还是蛮复杂的。 所谓闭包，在Javascript高级程序设计书中指有权访问另一个函数作用域中的变量的函数 理解闭包，首先等先理解作用域 所谓作用域主要是指全局作用域和局部作用域，在局部作用域内可以直接读取全局作用域，而全局作用域无法直接读取局部作用域的变量。 那么，如果要在全局作用域中读取局部作用域中的变量呢？ 这时，就可以使用闭包。 闭包的好处有：1、外部作用域可以访问内部作用域的变量2、可以是变量在内存中持久化]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016前端学习（二）]]></title>
    <url>%2F2016%2F01%2F25%2Flearning%2Ffront-end%2Fjavascripts%2Flearning-2016-2%2F</url>
    <content type="text"><![CDATA[之前总结了基本类型的判断和检测，现在来总结下Javascript中对象的原型和继承 二、对象与原型首先建立各一个简单的对象 12345678var person = new Object();person.name = &apos;tuzkiss&apos;;person.age = 24;person.job = &apos;Front-end developer&apos;;person.sayHi = function () &#123; alert(this.name)&#125;; 在ECMAScript中有两种属性，数据属性和访问器属性。 数据属性 ： 包含一个数据值位置，在这个位置可以读取或者写入值。有4个特性1、【Configurable】 ： 表示是否通过delete删除属性， 是是否能修改属性的特性， 或者是否能把修改成访问器属性。默认为true。2、【Enumerable】 : 表示能否通过for-in循环返回属性。默认为true。3、【Writable】 : 表示能否修改属性的值。默认为true。4、【Value】 : 包含这个属性的值。默认值为undefined。 如果要修改默认属性的特性的话，必须使用ECMAScript5中的Object.defineProperty()方法。这个方法介绍三个参数，属性所在的对象， 属性的名称， 一个描述符的对象。 描述符的属性是上面4种种的。 例如 ： 123456789var person = &#123;&#125;;Object.defineProperty(person, &apos;name&apos;, &#123; writable : false, value : &apos;tuzkiss&apos;&#125;);console.log(person.name); // tuzkissperson.name = &apos;tom&apos;;console.log(person.name); // tuzkiss 上述person对象中配置了writable为false，之后的修改都无法生效。 可以多次使用Object.defineProperty()方法修改同一个属性，但在把configurable特性设置为false之后就会有限制了。 访问器属性 访问器属性不包含数据值，包含一堆getter和setter函数。同样，访问器属性也拥有4个特性 1、【Configurabel】 : 表示能否通过delete删除属性重新定义属性，能否修改属性的特性，或者说修改成数据属性。默认值为true。2、【Enumerable】 : 表示能否通过for-in循环返回属性。默认为true。3、【Get】 : 在读取属性是调用的函数，默认为undefined。4、【Set】 : 在写入属性是调用的函数，默认为undefined。 例如 ： 123456789101112131415161718192021var book = &#123; _year : 2004, edition : 1&#125;;Object.defineProperty(book, &apos;year&apos;, &#123; get : function () &#123; return this._year; &#125;, set : function (newValue) &#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;console.log(book.edition); // 2 以上代码创建了一个book对象，给它定义了两个默认的属性： _year和edition。然后使用Object.defineProperty()添加year属性，同时改写get和set方法。 当然 也可以同时创建多个属性。 那么，现在才进入正题 ： 1、创建对象工厂模式 例如， 123456789101112131415function createPerson (name ,age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayHi = function () &#123; alert(this.name); &#125; return o;&#125;;var tuzkiss = createPerson(&apos;tuzkiss&apos;, 24, &apos;FEer&apos;); 构造函数模式 例如： 1234567891011function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayHi = function () &#123; alert(this.name); &#125;&#125;;var tuzkiss = new Person(&apos;tuzkiss&apos;, 24, &apos;FEer&apos;); 构造函数模式（Person）跟 工厂模式（createPerson）有以下区别之处： 没有显式的创建对象 直接降属性或方法付给了this对象 没有return 语句 使用构造函数创建对象时实际经历4个步骤：1、创建一个新的对象2、将构造函数的作用域赋给新对象（所以this指向了这个新对象）3、执行构造函数中的代码 （为这个新对象添加属性）4、返回新对象 所以 ： 123tuzkiss.constructor === Person; // truetuzkiss instanceof Person; // true 原型模式 我们创建的每一个函数都有一个prototype属性，这个属性是一个指针，指向一个对象。 例如： 1234567891011function Person () &#123;&#125;;Person.prototype.name = &apos;tuzkiss&apos;;Person.prototype.age = 24;Person.prototype.job = &apos;FEer&apos;;Person.prototype.sayHi = function () &#123; alert(this.name);&#125;var tuzkiss = new Person();tuzkiss.sayHi(); // &apos;tuzkiss&apos; 2、理解原型]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016前端学习（一）]]></title>
    <url>%2F2016%2F01%2F24%2Flearning%2Ffront-end%2Fjavascripts%2Flearning-2016-1%2F</url>
    <content type="text"><![CDATA[之前说了那么多雄心壮志的话，包括喝了浓浓的鸡汤，总要做点什么咯？是吧，没有人可以动动嘴皮子或者码点字就去改变世界的（特定的人除外）。so， 向着前端架构师的方向，有距离不可怕，可怕的是想要前进的渴望和信仰。 会慢慢总结一些关于前端学习方面的知识，同时也要跟上看书的节奏。首先先回顾下这些呗，听说是某个面试官leader出的题：js 数据类型以及判断，原型和继承，基于闭包实现唯一生成id，跨域，jsonp 具体实现代码，dom事件和自定义事件系统，前端路由，具体组件api设计和开发；css 常用布局属性，盒模型相关，position，sticky 效果，flex 布局。 一、JS数据类型已经判断javascript中的数据类型主要分为以下几种： 1、Number2、String3、Boolean4、Null5、Undefined6、Object 前五种是JS的基本类型，最后一种Object 包括几种特殊的类型，包括有Function, Array等等。 首先先回顾一下判断类型的几种方法： 1、typeof // 直接判断类型 2、instance // 判断变量是否从某个对象中构造器来？ 3、Object.prototype.toString.call() // 使用对象原型链上的方法 typeof首先定义一些常用的变量，例如下面 并且输入它们的typeof的值 1234567891011var i = 233;var s = &apos;string&apos;;var b = true;var n = null;var u;var o = new Object();var w = new RegExp();var x = [];var y = &#123;&#125;;var z = function () &#123;&#125;; 输入上面各个值的typeof 1234567891011console.log(typeof i); // numberconsole.log(typeof s); // stringconsole.log(typeof b); //booleanconsole.log(typeof n); // object console.log(typeof u); // undefinedconsole.log(typeof o); // objectconsole.log(typeof w); // objectconsole.log(typeof x); // objectconsole.log(typeof y); // objectconsole.log(typeof z); // function 上述代码中可以看到，基本类型中，除了null之外都会返回正常的类型判断。至于typeof null 为什么会等于object? 1995年JS诞生时，根本没把null当作数据类型，而是Object的一种特殊值。下面是当年C源码，其中完全没考虑null。这就是typeof null === object的根本原因。。。 那么简单的number，string， boolean， undefined可以直接使用typeof 进行判断。 而下面其中特殊的对象类型function使用typeof检测也可以返回正确的值 instanceof如果变量是给定引用类型的实例时，instanceof操作符就会返回ture。 1234567891011121314151617var instanceofVariable = function (variable, type) &#123; &quot;use strict&quot;; console.log(variable instanceof type);&#125;;instanceofVariable(i, Number); // falseinstanceofVariable(s, String); // falseinstanceofVariable(b, Boolean); // falseinstanceofVariable(n, Object); // false// instanceofVariable(u, ...); instanceofVariable(o, Object); // trueinstanceofVariable(w, RegExp); // trueinstanceofVariable(x, Array); // trueinstanceofVariable(y, Object); // trueinstanceofVariable(z, Object); // true 上述代码的结果可见，instanceof只能用于检测对象类型的数据, 然后null instanceof Object === false Object.prototype.toString.call那么问题来了？ 如果判断一个对象类型呢？不可能去每一种对象类型都去判断一下，所以我们使用Object.prototype.toString.call， 已经每个对象的原型链末端均为Object， 也就是说每个对象都是Obect的实例，使用可以调用Object原型链上的toString方法。 1234567891011121314151617var toStringCall = function (variable) &#123; &quot;use strict&quot;; console.log(Object.prototype.toString.call(variable));&#125;;toStringCall(i); // [object Number]toStringCall(s); // [object String]toStringCall(b); // [object Boolean]toStringCall(n); // [object Null]toStringCall(u); // [object Undefined]toStringCall(o); // [object Object]toStringCall(w); // [object RegExp]toStringCall(x); // [object Array]toStringCall(y); // [object Object]toStringCall(z); // [object Function] WOW 使用Object.prototype.toString.call返回了所以的正确结果咯， 然后为什么基本类型也会返回？ 在ES5中Object.prototype.toString规范如下 15.2.4.2 Object.prototype.toString ( )在toString方法被调用时,会执行下面的操作步骤:1、如果this的值为undefined,则返回”[object Undefined]”.2、如果this的值为null,则返回”[object Null]”.3、让O成为调用ToObject(this)的结果.4、让class成为O的内部属性[[Class]]的值.5、返回三个字符串”[object “, class, 以及 “]”连接后的新字符串. 总结 ：1、那么对于基本类型的判断除null以外可以使用typeof2、对于特性的对象可以使用instanceof判断3、对于未知的对象类型，使用Object.prototype.toString判断即可。 不过貌似ES6中能有新的类型，到时候在添上。 PS，上述中遗漏了Date类型的对象，可以自行添加]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十年后WEB架构]]></title>
    <url>%2F2016%2F01%2F07%2Fproject%2Fwebsite%2F10years%2F</url>
    <content type="text"><![CDATA[现在是北京时间的2016年01月07日16:32:35，准备开始整理下十年后项目的架构，主要是WEB。大致上使用了baidu的脑图，下面的链接可以打开到具体的页面查看脑图(如果打不开或者错误，请刷新页面重试下)。 版本 1.0.0 作者 TuzK1ss 更新 2016-01-07 1、十年后产品产品介绍 ： 十年后是 … 首先是整个十年后产品的的架构： 脑图地址为： 地址 十年后的产品主要分为三大块: 1、Server （服务端）服务端主要是服务器（apache），数据库（mysql），后台（php）等。 2、Web （网页端）网页端主要是两个站点，一个正式服，一个测试服 3、App （应用端）App端主要分为Android和iOS客户端。 2、十年后WEB架构首先是十年后WEB的及架构 百度脑图地址为 : 地址 十年后WEB主要分为以下几块： 1、开发语言主要使用了HTML, CSS, Javascript，不过新的采用的CSS的预处理器SASS，可以在最大程度上重用代码和管理代码。 2、第三方类库 (主要)WEB主要使用一些Javascript的第三方类库： jQuery.js 基础类库 require.js 基础模块化类库 timeline.js 时间轴类库 simditor.js HTML5日志编辑器类库 jQuery.fullPage.js 登陆页面全屏滚动类库 Zepto.js 移动端页面基础类库3、模板引擎 WEB中使用到了2中模板引擎，分别是： Twig (php后台渲染模板) 官网地址 doT (js前台渲染模板) 官网地址4、模块化加载 WEB中使用AMD的加载方式，所以引入requrire.js作为加载js。 PS:在开发中会书写Javascript会同一使用UMD（Universal Module Definition）加载方式书写，如下：12345678910111213141516171819202122232425262728293031323334(function (root, factory) &#123; 'use strict'; if (typeof define === 'function' &amp;&amp; define.amd) &#123; // 引入所需模块，例如 define(['jquery'], factory); define([], factory); &#125; else if (module.export === 'Object') &#123; // 引入所需模块，例如 module.export = factory(require('jquery')); module.export = factory(); &#125; else &#123; // 引入所需模块，例如 root.module = factory(jQuery); // 同时需要修改具体方法中的传入值，例如 （this, function ($)&#123;&#125;) // 修改module name root.module = factory(); &#125;&#125;(this, function () &#123; 'use strict'; // 创建具体的模块内容 var module = &#123; initialize : function () &#123; // &#125; &#125;; // 返回模块初始化话函数 return module.initialize();&#125;)); 5、自动化构建使用gulp来作为自动化构建工具，教程可参考 地址1 和 地址2 主要使用到gulp作为自动化构建工具的功能有： 编译SASS 编译ES2015（后期） 为静态文件添加md5后缀6、文件夹结构 · ├─ application （WEB应用文件夹啊） | ├── … （其他文件夹） | └── views (HTML页面) ├─ static （静态资源） | ├── build (gulp编译之后自动生成的文件夹) | ├── css （静态CSS文件） | ├── images （静态图片文件） | ├── sass （SCSS文件） | ├── scripts （静态Javascript文件） 其中有些文件夹下面会存在三个子文件夹 ： common 通用文件 libs 第三方文件 view/core 页面文件/核心文件7、页面结构 还是看图比较直观吧： 3、十年后WEB系统功能十年后WEB作为一个SNS的社交网站，主要分为 用户未登录 和 用户已登录 的状态。 具体的脑图地址为: 地址 1、未登录 在未登录的情况下，用户可以注册，查看一些允许的页面。如果该用户进行一些操作，例如点赞，评论等需要提示该用户登录或者注册。 2、登录 用户在登录情况下允许以下操作: 查看公开的所有页面 查看个人的消息通知（即来往） 进行一系列的操作 （包括发布状态，点赞，评论等等） 未完待续…]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识webpack]]></title>
    <url>%2F2015%2F12%2F30%2Fproject%2Fbuild-tools%2Fwebpack-first-experience%2F</url>
    <content type="text"><![CDATA[之前看了点gulp的工作流，能基本使用gulp合并压缩并可以在项目中使用SASS和ES2015。然后听说前端业界还有个叫做webpack的比较火的module bundler，就抽空学习了下webpack，可以简单的打包SASS与ES2015的项目。 首先需要安装webpack 1$ npm install -g webpack 然后创建项目，大致目录和文件如下： 其中 build， 和node_modules是自动生成的文件夹 之后创建我们的入口文件 entry.js和webpack配置文件 ： webpack.config.js 1234567891011121314151617var path = require(&apos;path&apos;);module.exports = &#123; entry : path.join(__dirname, &apos;./src/entry.js&apos;), output : &#123; path : path.join(__dirname, &apos;./build&apos;), filename : &apos;bundle.js&apos; &#125;, module : &#123; loaders :[ &#123; test : /\.es6/, loader : &apos;babel?presets[]=es2015&apos;&#125;, &#123; test : /\.css$/, loader : &apos;style!css&apos;&#125;, &#123; test : /\.(png|jpg)$/, loader : &apos;url!limit=8192&apos;&#125;, &#123; test : /\.scss/, loader : &apos;style!css!sass&apos;&#125; ] &#125;&#125;; 具体配置可以去webpack官网中查看，具体需要知道的是需要之前引入一些sass和es2015编译需要的module 和一些loader 下面是package.json 文件中的依赖配置： 123456789101112&quot;devDependencies&quot;: &#123; &quot;babel-core&quot;: &quot;^6.3.26&quot;, &quot;babel-loader&quot;: &quot;^6.2.0&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.3.13&quot;, &quot;css-loader&quot;: &quot;^0.23.1&quot;, &quot;file-loader&quot;: &quot;^0.8.5&quot;, &quot;node-sass&quot;: &quot;^3.4.2&quot;, &quot;sass-loader&quot;: &quot;^3.1.2&quot;, &quot;style-loader&quot;: &quot;^0.13.0&quot;, &quot;url-loader&quot;: &quot;^0.5.7&quot;, &quot;webpack&quot;: &quot;^1.12.9&quot; &#125; 然后在SASS文件夹下创建index.scss， 简单的写。。。 1234$primary-color: #00b498;body &#123; background : $primary-color;&#125; 在ES2015文件夹下创建index.es6, 12let a = 2;module.exports = a; 最后编写我们的入口文件entry.js 12require(&apos;./es2015/index.es6&apos;);require(&apos;./sass/index.scss&apos;); 这样之后，输入简单的webpack，就可以成功运行webpack打包程序。。 写的好乱好乱。。。哎。。看来没有状态，到时候在整理吧。。]]></content>
      <tags>
        <tag>Build Tool</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快排（二）]]></title>
    <url>%2F2015%2F12%2F29%2Flearning%2Falgorithm%2Fquick-sort-object%2F</url>
    <content type="text"><![CDATA[今天在看到排序的时候突然想到自己很久没复习算法了，就随手把快排的算法写了一遍。 最基本的代码如下：12345678910111213141516171819202122var quickSort = function (arr) &#123; var len = arr.length, val = arr[0], left = [], right = []; if (len &lt;= 1) &#123; return arr; &#125; for (var i = 1; i &lt; len; i ++) &#123; if (arr[i] &lt; val) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return arguments.callee(left).concat(val, arguments.callee(right));&#125;; 这段代码中用到了arguments.callee， 之前在看《JS高程》的时候看到，觉得有时候还是蛮有用的。arguments.callee指向的是该函数，这样就可以随意更改quickSort的函数名而不影响正常的运行。但是，这样存在一个小问题，就是在严格模式下无法使用arguments.callee。。。 上述是最基本的快排代码，跟默认的array.sort原理差不多，类似与下列代码，但是数据越大时快排的优势就体现出来了： 12345var arr = [2, 1, 3, 4, 0];arr.sort(function (a, b) &#123; return a - b;&#125;); 但是这样只能排序一个数值数组，如果是一个object-array呢？ 那么先从简单的开始改写： 1234567891011var objArr = [ &#123; id : 2, name : &apos;tuzkiss&apos; &#125;, &#123; id : 1, name : &apos;john&apos; &#125;, &#123; id : 3, name : &apos;eric&apos; &#125;, &#123; id : 4, name : &apos;tom&apos; &#125;, &#123; id : 0, name : &apos;cherry&apos; &#125;];objArr.sort(function (a, b) &#123; return a.id - b.id;&#125;); 上述代码中改写了sort中传入的函数返回，即带上了需要比较的key（”id”）, 控制台中输出如下： 那么？ 怎么改写快排呢？让它也支持对象排序呢？1234567891011121314151617181920212223242526272829303132var quickSort = function (arr, key) &#123; var len = arr.length, val = arr[0], left = [], right = []; if (len &lt;= 1) &#123; return arr; &#125; for (var i = 1; i &lt; len; i ++) &#123; if (!key) &#123; if (arr[i] &lt; val) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; else &#123; if (arr[i][key] &lt; val[key]) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; &#125; return arguments.callee(left).concat(val, arguments.callee(right));&#125;; 添加了一个参数key，用于传递是否要比较对象中的某个key，如果key参数存在的话，则按照对象数组的方式去比较。 1quickSort(objArr, &apos;id&apos;); 输出跟上面的图片是一样。 然后你说，你想测试下性能？ 行啊~ 接着看先创建一个随机生成数组的函数，可以传入数组个数的函数： 123456789101112var count = 100;var createArr = function (count) &#123; var arr = []; for (var i = 0 ; i &lt; count ; i ++) &#123; arr.push(Math.floor(Math.random() * 1000)); &#125; return arr;&#125;;var arr = createArr(count); 结果如下图： 稍后有空再补上]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点击事件绑定]]></title>
    <url>%2F2015%2F12%2F26%2Fproject%2Ffront-end%2Fbind-events%2F</url>
    <content type="text"><![CDATA[昨天把项目中的动态页面样式用SASS改写完成，今天开始写动态交互事件。基于之前的项目使用方式，都是一个单独的事件绑定在body元素上，但是这样存在一个问题，就是如果需要绑定的事件太多，就存在一个body元素上绑定了N个click事件。作为一个有强迫症+些许代码设计优美的码农是不能忍，所以就在考虑是否用一些更加优美简洁的语法来写。 在google了下之后，找到了“CSS魔法哥”的一篇日志，看了还是蛮有启发的。 具体正文地位为： (https://github.com/cssmagic/blog/issues/48) 在魔法哥的日志中从基础到完善的介绍了事件绑定的原理和比较优秀的做法。 那么我稍微总结一下呗 ：在动态页面中，需要绑定的事件大概有点赞，获取评论等等，大约10个左右。准备使用统一的class来只使用一个事件绑定，例如使用class “js-action” : 12345678910111213$(document.body).on(&apos;click&apos;, &apos;.js-action&apos;, function () &#123; $this = $(this); config = &#123; id : parseInt($this.data(&apos;id&apos;), 10), type : parseInt($this.data(&apos;type&apos;), 10) &#125;; action = $this.data(&apos;action&apos;); typeof actionList[action] === &apos;function&apos; &amp;&amp; actionList[action]($this, config);&#125;); 使用事件代理， 让通用的class来作为事件的唯一入口，通过该元素上的自定义属性data-action来具体判断是什么操作，以及为一些必要的添加自定义属性，例如data-id等。 这样的好处就是可以减少事件绑定，减少代码量，同时具体拓展性。（具体拓展性等下会降到） 通过绑定事件来获取该事件的action，然后建立起一个对应的对象，用键值对的方式，每个action对应相应操作的funcion。例如 ： 123456789101112131415161718192021222324252627/** * 操作事件列表对象 */var actionList : &#123; /** * 点赞事件 * * @param &#123;Object&#125; $this * @param &#123;Object&#125; config */ like : function ($this, config) &#123; // 此处省略具体点赞操作代码 &#125;, /** * 展开动态操作事件 * * @param &#123;Object&#125; $this * @param &#123;Object&#125; config */ showOperation : function ($this, config) &#123; // 此处省略具体的战士操作代码 &#125; //...&#125; 这样每个action点击时，会去调用action对应的function，并执行。跟绑定在该元素上进行操作是一样的。 这样就可以完美解决多个事件需要动态绑定，同时不需要多个事件代理的写法。 同时，这样的做法也提高的拓展性，只需要简单几步就可以绑定需要的事件：1、在需要绑定的元素上添加class，例如“js-action”, 指定其data-action属性，同时为其添加需要用到的自定义属性。2、为actionList添加对应data-action的function。例如可以先写好统一的拓展方法 ： 123456789/** * 为action list添加新的action跟function * * @param &#123;string&#125; action * @param &#123;Function&#125; actionFunction */actionList.add = function (action , actionFunction) &#123; actionList[action] = actionFunction;&#125;; 哈哈，这是最简单的写法，当然如果想用类的思想来改写，可以在构造器的原型链上添加该方法。 学到老，活到老。 希望再前端的路上越走越远~ 加油 :fist:]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纯CSS hover 提示框]]></title>
    <url>%2F2015%2F12%2F23%2Fproject%2Ffront-end%2Fprue-css-hover%2F</url>
    <content type="text"><![CDATA[现在是北京时间的2015年12月23日23:01:43，好久没码字了，手有点痒了。好吧，其实是之前有段时间过得有些心累，而且也偷懒了，之前买的《高程》也是看了200页之后荒废了。哎，想要让自己变得强大还是要坚持内心的渴望。 闲话少说，进入正题。 最近开始再重写项目中的主体，动态的详细页面时，突然想到可不可以添加一个提示框，因为对于有些需要提示的地方使用原生的title属性感觉效果并不好，所以考虑自己手动写一个hover提示效果。 然后之前看到过可以在:before / :after伪类中的content属性使用 DOM的属性attr(data-*)，好像我大github的提示效果就是这么做的吧。。 那么，首先定一个class，例如ty-tip。HTML的代码为： 1&lt;div class=&quot;ty-tip&quot; data-title=&quot;查看更多&quot;&gt; &lt;/div&gt; 然后为其定义CSS样式（因为重写使用了SASS，所以下面是SASS语法的代码） 依赖两个基础的mixin ：123456789101112131415@mixin transition ($time : .3s) &#123; -webkit-transition: all $time ease-in-out; -moz-transition: all $time ease-in-out; -ms-transition: all $time ease-in-out; -o-transition: all $time ease-in-out; transition: all $time ease-in-out;&#125;@mixin translate($x : 0, $y : 0, $z : 0) &#123; -webkit-transform: translate3d($x, $y, $z); -moz-transform: translate3d($x, $y, $z); -ms-transform: translate3d($x, $y, $z); -o-transform: translate3d($x, $y, $z); transform: translate3d($x, $y, $z);&#125; 下面是具体的ty-tip代码（scss）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667.ty-tip &#123; position: relative; -webkit-backface-visibility: hidden; backface-visibility: hidden; @include translate(); &amp;:before, &amp;:after &#123; z-index: -1; opacity: 0; @include translate(0, 3px, 0); @include transition(); &#125; &amp;:before&#123; content: &apos;&apos;; position: absolute; width: 0; height: 0; border:6px solid transparent; border-top-color:rgba(0, 0, 0, .6); top: -7px; left: 50%; margin-left: -6px; z-index: 10; overflow: hidden; &#125; &amp;:after &#123; content: attr(data-title); position: absolute; display: inline-block; background: rgba(0, 0, 0, .6); color: #fff; padding: 3px 4px; top: 0; font-size: 12px; line-height: 18px; height: 17px; width: auto; min-width: 60px; text-align: center; left: 50%; margin-top: -30px; margin-left: -33px; overflow: hidden; @include boxShadow(0 0 3px #ddd); @include borderRadius(5px); &#125; &amp;:hover:before , &amp;:hover:after &#123; z-index: 1; opacity: 1; @include translate(0, 0, 0); &#125; &amp;:hover:before &#123; z-index: 10; &#125;&#125; 效果图为： 核心思想是：使用:before伪类元素来创建向下的箭头，用:after元素来创建提示主体正文。默认状态为opacity ：0， z-index:-1, transform : translate3d(0, 3px, 0); Hover 时，分别把透明度设为1，层级提高，并且移动到指定位置。 用到的坑 ： 遇到的坑主要是两个：1、如何让主体元素始终跟hover元素居中？解决方法是：绝对定位的:after 元素 left设置为 50%， 同时margin-left 的值为 :after元素的50% 与:bofore元素的50%的负数，上例中也就是（margin-left: - (30 + 4) px）。 这样就可以让提示元素始终居中了。 2、在Chrome下面，hover时出现tip提示框会导致有些DOM元素莫名的消失？解决方法是：这个问题困扰好久，而且使用firefox跟safari中hover不会存在在问题。google了一通之后，发现可能是Chrome的GPU渲染时会导致有些DOM消失不见。SO， 需要添加以下代码在ty-tipz中 123-webkit-backface-visibility: hidden; backface-visibility: hidden; @include translate(); 使改提示框在不可见的时候隐藏，同时设置其translateZ 为 0； # 这样就完成一个简单的纯CSS提示框，可以在需要提示的元素上添加改样式名，或者在需要的父元素添加一个span元素，同时设置span元素的class为ty-tip，然后添加data-title属性即可。 是不是很EASY… 学以致用，加油~]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6+SASS 项目总结]]></title>
    <url>%2F2015%2F12%2F17%2Fproject%2Fwebsite%2Funicornstartup%2F</url>
    <content type="text"><![CDATA[现在是北京时间的2015年12月17日00:17:28，刚忙完上线的站点，然后准备把该项目总结一下，不然总觉得拖着拖着又不了了之了。:joy: 一、项目简述该项目名字叫做 “独角兽”，目前线上地址为 地址 ， 后台使用php + mysql , 使用twig模板引擎，前端采用了HTML5 + ES6 + SASS，使用自动化构建工具gulp编译sass和es6，同时为静态文件添加md5后缀。 二、项目准备后台不需要考虑，前端使用gulp作为自动化构建基础。 gulp基础构建请移步至gulp学习一 主要的gulp流程为 【clean】 =&gt; 【html】 =&gt;【sass】 =&gt; 【es6】 并同时添加 3个watch， 用于监控文件改变实时生成最新的文件（貌似最新有个叫做热更新的，等有时间了可以研究下看看） 主要的task为【sass】 和【es6】,【sass】主要思想是 【sass文件】 =&gt;（gulp-sass） 【css多个文件】 =&gt; (gulp-concat) 【css单个文件】 =&gt; (gulp-minify-css) =&gt; 【css压缩文件】 =&gt;（gulp-md5-plus） 【css带md5文件】 【es6】主要思想是 【es6文件】 =&gt; (gulp-babel) 【js多个文件】 =&gt; (gulp-concat) 【js单个文件】 =&gt; (gulp-uglify) 【js压缩文件】 =&gt; (gulp-md5-plus) 【js带md5文件】 然后 需要在开发的过程中启动 gulp watch 。 三、项目开发sass 文件分为3个.scss文件， 分别为 ：variable.scss =&gt; 常用变量，和mixinbase.scss =&gt; 通用的样式，import variableindex.scss =&gt; 具体样式 ， import base 样式开发中使用PC优先，兼容mobile的思想，使用@media query 兼容主流的mobile browser。 es6 文件主要分为2个.es6文件，分别为：base.es6 =&gt; 通用的方法和属性index.es6 =&gt; 具体的方法 在es6文件中依旧使用之前熟悉的UMD加载方法 ： 123456789101112131415((root, factory) =&gt; &#123; &apos;use strict&apos;; if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123; define([], factory); &#125; else if (typeof module === &apos;object&apos;) &#123; module.exports = factory(); &#125; else &#123; root.XXX = factory(); &#125;&#125;)(window, () =&gt; &#123; &apos;use strict&apos;; // 此处省略具体代码&#125;); 四、项目总结终于迈出了es6+sass项目的第一步，在学习中使用，在使用中学习，然后准备把主站点十年后也升级到es6+sass，同时添加gulp自动化构建工具。 当然，在新技术带来便利的同时，也或多或少的遇到一些坑，暂时总结与思考如下： 1、sass中使用多层嵌套导致class多长是否会影响页面渲染性能？这个暂时未知2、sass中因为PC优先，使用了镀层嵌套之后，在兼容移动端时也需要大于等于的嵌套来覆盖样式，是否有更好的解决方法？3、sass是否可以做成热更新，不需要每一次更改文件之后手动去刷新页面。4、es6中目前使用到的更多是let 和 =&gt;， 是否可以用到更多的新属性？5、=&gt; 符号指代是无法使用this，所以=&gt;符号更好适用于什么情况下，暂时未知。6、目前借助于第三方的js类库，zepto， 是否可以用原生的js构建整个项目。（之前开发静态页面时，均使用原生js，后来因为需要用到ajax所以引入了zepto，等看完基础的ajax，是否可以自己封装一个建议的ajax方法）7、还是要多学习，多看看业界内新技术和工具，不光会在效率上提升，更会更加符合未来的语言发展趋势。8、嗯。好像暂时没想到其他的了。然后这个项目做的也是很赶很急，累感不爱。:joy:]]></content>
      <tags>
        <tag>ES6</tag>
        <tag>SASS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习 （一）]]></title>
    <url>%2F2015%2F12%2F02%2Flearning%2Ffront-end%2Fcss%2Fcss-experience-1%2F</url>
    <content type="text"><![CDATA[1、关于margin: 0 auto; 居中原理对于块级元素来说，默认的width为100%的父元素的width, 当我们设定了该元素的width之后，可以使用margin:0 auto;把改元素居中，是因为使用了auto后会默认填充满宽度，而我们设定了左右的margin都为auto，则margin-left和margin-right会平分父元素100% - 元素width ，所以实现了水平居中。 ps.如果把margin:0 auto;改为padding: 0 auto;则不会使元素width变为100%； 2、pointer-events:none 使用在使用css美化select元素时，需要为其添加一个自定义的下了箭头，使用父元素的after伪类实现，但是，鼠标点击无法触发select事件，之前用过很蠢的做法就是，去绑定如果点击了该父元素，则触发改父元素下的select点击事件。今天，又学到了个新的知识，pointer-events:none， 可以把鼠标事件禁用掉，相当于成为了“幻影”箭头，点击箭头可以触发select 下拉。 3、Chrome下transition过程中会导致一些DOM元素不可见在使用:after属性content : attr(data-title)制作提示框时，遇到在Chrome下神奇的问题，如该题目。网上看到原因可能为This is Chrome bug that sometimes appears for some reason. All absolute-positioned elements inside hardware-accelerated container (e.g. slides) must have rsAbsoluteEl class, or just such css styles to force hw acceleration on element that blinks:所以需要添加这个样式 ： -webkit-backface-visibility: hidden;transform : translateZ(0); 就可以解决改问题。NICE ~ :joy:]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp学习]]></title>
    <url>%2F2015%2F11%2F12%2Fproject%2Fbuild-tools%2Fgulp-experience%2F</url>
    <content type="text"><![CDATA[在忙碌了几个月之后终于还是项目开始慢慢的进入优化改进期间，当然也不能闲着，之前看会点ES2015的新内容，学了node的基本操作，加上准备学习下gulp和webpack。今天稍微能让gulp运行项目了，就在这总结一下。（因为之前有用过grunt，所以学起来还是蛮顺手和蛮快的） 1.首先需要全局安装gulp在命令行中输入安装命令： 1npm install gulp -g (之前一直无法安装全局gulp，而且找不到原因，后来把npm卸载和重新安装了node，如果又遇到类似的情况，可以尝试下) 2.在项目下安装gulp在命令行中输入安装命令（需要到该项目路径下）： 1npm install gulp --save-dev –save : 是添加到本地项目文件中-dev : 是添加到package.json中的devDependencies 添加这样的命令安装时会自动添加到package.json的devDependencies，然后如果重置项目或者他人使用项目是只需要使用 1npm install 就能完成项目所需的模块加载。 3.创建gulpfile.js首先需要引入gulp模块，然后使用gulp.task创建任务。默认可以使用default任务 123456var gulp = require(&apos;gulp&apos;);gulp.task(&apos;default&apos;, function ()&#123; &quot;use strict&quot;;&#125;); 4.运行gulp在命令中输入gulp就可运行默认的default任务（需要到该项目路径下）： 1gulp 这样就一个初始的gulp任务创建完成。 5.添加gulp其他任务目前常用的任务有，css的编译（如果需要），合并，压缩，script的合并，压缩，html内的替换路径等。 下面是对应的模块名css的合并 ： gulp-concat-csscss的压缩 ： gulp-minify-cssscript的合并 ： gulp-concatscript的压缩 ： gulp-uglifyhtml的替换 ： gulp-html-replace清理文件夹 ： gulp-clean加密文件 ： gulp-md5-plus 1npm install --save-dev gulp-clean gulp-concat gulp-concat-css gulp-html-replace gulp-md5-plus gulp-minify-css gulp-rename gulp-uglify 然后引入到gulpfile.js中 12345678var concat = require(&apos;gulp-concat&apos;);var uglify = require(&apos;gulp-uglify&apos;);var rename = require(&apos;gulp-rename&apos;);var minifyCss = require(&apos;gulp-minify-css&apos;);var concatCss = require(&apos;gulp-concat-css&apos;);var htmlReplace = require(&apos;gulp-html-replace&apos;);var clean = require(&apos;gulp-clean&apos;);var md5 = require(&apos;gulp-md5-plus&apos;); 6.确定任务流程ps. 以下用到的version变量为项目的版本号 12var pjson = require(&apos;./package.json&apos;);var version = pjson.version; 我们的项目中开发文件都存放在src文件夹下， 分别为css， scripts, images 文件夹和html文件。需要在项目发布的时候把需要用到的css打包成一个文件然后压缩，并引入到html文件中， script同理。然后把发布的文件放在build文件夹下，同时每次发布项目是需要重新构建build文件夹。 首先创建一个clean任务，用于删除build文件夹 12345gulp.task(&apos;clean&apos;, () =&gt; &#123; &quot;use strict&quot;; return gulp.src(&apos;./build&apos;) .pipe(clean(&#123;force : true&#125;));&#125;); 然后创建一个css任务，用于合并css和压缩css 12345678910gulp.task(&apos;css&apos;, [&apos;clean&apos;], () =&gt; &#123; &quot;use strict&quot;; return gulp.src(&apos;./src/css/**/*.css&apos;) .pipe(concatCss(&apos;index_&apos; + version + &apos;.css&apos;)) .pipe(gulp.dest(&apos;./build/css&apos;)) .pipe(rename(&apos;index_&apos; + version + &apos;.min.css&apos;)) .pipe(minifyCss()) .pipe(gulp.dest(&apos;./build/css&apos;));&#125;); task 中第二个参数如果为数组的话，就说明这个task需要在数组里面的task都完成之后才会执行。 然后创建scripts 任务， 用于合并scripts和压缩scripts 12345678910gulp.task(&apos;script&apos;, [&apos;clean&apos;], () =&gt; &#123; &quot;use strict&quot;; return gulp.src(&apos;./src/scripts/**/*.js&apos;) .pipe(concat(&apos;index_&apos; + version + &apos;.js&apos;)) .pipe(gulp.dest(&apos;./build/scripts&apos;)) .pipe(rename(&apos;index_&apos; + version + &apos;.min.js&apos;)) .pipe(uglify()) .pipe(gulp.dest(&apos;./build/scripts&apos;));&#125;); 之后创建html任务，用于替换更换css和script的链接 ···gulp.task(‘html’, [‘css’, ‘script’], () =&gt; { “use strict”; 123456return gulp.src(&apos;./src/index.html&apos;) .pipe(htmlReplace(&#123; &apos;css&apos; : &apos;./css/index_&apos; + version +&apos;.min.css&apos;, &apos;js&apos; : &apos;./scripts/index_&apos; + version + &apos;.min.js&apos; &#125;)) .pipe(gulp.dest(&apos;./build&apos;)); });··· 然后创建一个md5任务， 用于更改不同的后缀，防止浏览器缓存 1234567891011gulp.task(&apos;md5&apos;, [&apos;html&apos;], () =&gt; &#123; &quot;use strict&quot;; gulp.src(&apos;./build/scripts/*.js&apos;) .pipe(md5(16, &apos;./build/*.html&apos;)) .pipe(gulp.dest(&apos;./build/scripts&apos;)); gulp.src(&apos;./build/css/*.css&apos;) .pipe(md5(16, &apos;./build/*.html&apos;)) .pipe(gulp.dest(&apos;./build/css&apos;));&#125;); 最后 更改我们的default 任务 ： 1234gulp.task(&apos;default&apos;, function ()&#123; &quot;use strict&quot;; gulp.run([&apos;clean&apos;, &apos;image&apos;, &apos;css&apos;, &apos;script&apos;, &apos;html&apos;, &apos;md5&apos;]);&#125;); 至此，我们常用的任务已经完成。 任务流程是 【clean】 =&gt; 【css, script】 =&gt; 【html】 =&gt; 【md5】 （后面的任务需要在前面的完成之后可以完全执行） 在命令行中运行gulp就完全执行我们的任务流程了。 如果需要单独执行某个命令的话 可以输入 gulp css (或其他task的名字)即可。 。。最近貌似webpack比较火，然后准备这两天在看看webpack，然后结合gulp建立一个相对完整的前端工作流。恩，加油。 2015年11月13日10:17:50 更新因为使用到了ES2015，所以想在项目生成的时候转化成ES5或其他，就需要用到babel。同时有gulp-babel的插件，以及转化ES2015的插件 babel-preset-es2015。 所以在命令中输入： 1npm install --save-dev gulp-babel babel-preset-es2015 然后在需要转化的JS后添加 123.pipe(babel(&#123; presets: [&apos;es2015&apos;]&#125;)) 最终我们的上述例子中的script的task为： 12345678910111213gulp.task(&apos;script&apos;, [&apos;clean&apos;], () =&gt; &#123; &quot;use strict&quot;; return gulp.src(&apos;./src/scripts/**/*.js&apos;) .pipe(babel(&#123; presets: [&apos;es2015&apos;] &#125;)) .pipe(concat(&apos;index_&apos; + version + &apos;.js&apos;)) .pipe(gulp.dest(&apos;./build/scripts&apos;)) .pipe(rename(&apos;index_&apos; + version + &apos;.min.js&apos;)) .pipe(uglify()) .pipe(gulp.dest(&apos;./build/scripts&apos;));&#125;); 这样就可以在我们的项目中使用ES2015了~ 新世界的大门= = 有木有:joy:]]></content>
      <tags>
        <tag>Build Tool</tag>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NODE 学习1]]></title>
    <url>%2F2015%2F11%2F10%2Flearning%2Ffront-end%2Fnode%2Fmy-first-app%2F</url>
    <content type="text"><![CDATA[链接 mongodb 1.首先启动mongodb1mongod 2.安装mongoose module, 同时引入到app.js 中1npm install mongoose 在app.js 中添加 12345var mongoose = require(&apos;mongoose&apos;);...mongoose.connect(&apos;mongodb://localhost/demo20151107&apos;); 3.在项目中新建两个新文件夹, models (存放数据库对象), schemas(数据架构?) ps.其实是这个是看别人的视频中学到的,现在还不知道做什么用1mkdir models schemas 4.创建user类和数据库操作方法在schemas中添加user.js, 123456789101112131415161718192021222324252627282930313233343536373839// 引入mongoose modulevar mongoose = require(&apos;mongoose&apos;);// 新建user schemavar UserSchemas = new mongoose.Schema(&#123; account : String, password : String, registerDate : Date, loginCount : Number, lastLoginDate : Date, accountType : Number&#125;);// user schemas statics functionUserSchemas.statics = &#123; fetch : function (cb) &#123; return this .find(&#123;&#125;) .exec(cb); &#125;, findById : function (id, cb) &#123; return this .findOne(&#123;_id : id&#125;) .exec(cb) &#125;, findByAccount : function (account, cb) &#123; return this .findOne(&#123;account : account&#125;) .exec(cb) &#125;, deleteByAccount : function (account, cb) &#123; return this .remove(&#123;account : account&#125;) .exec(cb); &#125;&#125;;// module exportmodule.exports = UserSchemas; 同时在models中创建user.js 12345var mongoose = require(&apos;mongoose&apos;);var UserSchemas = require(&apos;../schemas/user&apos;);var User = mongoose.model(&apos;User&apos;, UserSchemas);module.exports = User; models中的user.js的作用是主要把之前创建的user对象转换成数据库模型 5.需要在app.js 中引入1var User = require(&apos;./models/user&apos;); 这样就可以在后面使用User的增删改查方法了. 6.在app.js中创建新增add路由1234567891011121314151617181920app.post(&apos;/add&apos;, function (req, res) &#123; var param = req.body; var user = new User(&#123; account : param.account, password : param.password, registerDate : new Date() &#125;); user.save(function (err, user) &#123; if (err) &#123; console.log(err); &#125; if (user)&#123; res.json(&#123;status: &apos;success&apos;, data : &#123; user : user &#125;&#125;); &#125; &#125;)&#125;); 7.在app.js中新增 delete路由12345678910111213app.post(&apos;/delete&apos;, function (req, res) &#123; var param = req.body; User.deleteByAccount(param.account, function (err, user) &#123; if (err) &#123; console.log(err); &#125; if (user) &#123; res.json(&#123;status : &apos;success&apos;&#125;); &#125; &#125;);&#125;); 8.在app.js中新增 modify路由123456789101112131415161718192021222324app.post(&apos;/modifyPassword&apos;, function (req, res) &#123; var param = req.body; User.findByAccount(param.account, function (err, user) &#123; if (err) &#123; console.log(err); &#125; if (user &amp;&amp; user.account === param.account) &#123; user.password = param.password; user.save(function (err, nuser) &#123; if(err) &#123; console.log(err); &#125; if (nuser) &#123; res.json(&#123;status : &apos;success&apos;&#125;); &#125; &#125;) &#125; &#125;)&#125;); 9.在app.js中使用查询功能,分为全部查询和单个查询12345678910111213141516171819202122232425262728293031323334app.get(&apos;/list&apos;, function (req, res) &#123; User.fetch(function (err, users) &#123; if (err) &#123; console.log(err); &#125; res.render(&apos;list&apos;, &#123; users : users &#125;); &#125;);&#125;);app.post(&apos;/checkLogin&apos;, function (req, res) &#123; var param = req.body; User.findByAccount(param.account, function (err, user) &#123; if(err) &#123; console.log(err); &#125; if (user) &#123; console.log(user); if (user.password === param.password) &#123; res.json(&#123;status : &apos;success&apos;&#125;); &#125; else &#123; res.json(&#123;status : &apos;fail&apos;&#125;); &#125; &#125; &#125;);&#125;); 最后在index.js中绑定按钮使用ajax去调用这些POST请求, 既可以简单的实现增删改查..附上 index.js 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102var index = &#123; init : function () &#123; console.log(&apos;index init...&apos;); this.registerUser() .checkSignIn() .modifyPassword() .deleteUser() &#125;, registerUser : function () &#123; var that = this; $(&apos;#register&apos;).on(&apos;click&apos;, function (e) &#123; e.preventDefault(); that.ajax(&apos;/add&apos;, function (res) &#123; console.log(res); if (res.status === &apos;success&apos;) &#123; alert(&apos;注册成功&apos;); &#125; &#125;); &#125;); return this; &#125;, checkSignIn : function () &#123; var that = this; $(&apos;#sign_in&apos;).on(&apos;click&apos;, function (e) &#123; e.preventDefault(); that.ajax(&apos;/checkLogin&apos;, function (res) &#123; console.log(res); if(res.status === &apos;success&apos;) &#123; location.href = &apos;/list&apos; &#125; &#125;); &#125;); return this; &#125;, modifyPassword : function () &#123; var that = this; $(&apos;#modify&apos;).on(&apos;click&apos;, function (e) &#123; e.preventDefault(); that.ajax(&apos;/modifyPassword&apos;, function (res) &#123; console.log(res); if (res.status === &apos;success&apos;) &#123; alert(&apos;modify success&apos;); &#125; &#125;) &#125;); return this; &#125;, deleteUser : function () &#123; var that = this; $(&apos;#delete&apos;).on(&apos;click&apos;, function (e) &#123; e.preventDefault(); that.ajax(&apos;/delete&apos;, function (res) &#123; console.log(res); if (res.status === &apos;success&apos;) &#123; alert(&apos;delete success&apos;); &#125; &#125;) &#125;); return this; &#125;, ajax : function (url, callback) &#123; var param = &#123; account : $(&apos;#account&apos;).val(), password : $(&apos;#password&apos;).val() &#125;; $.ajax(&#123; type : &apos;post&apos;, url : url, data : param, dataType : &apos;json&apos; &#125;).done(callback); &#125;&#125;;index.init();]]></content>
      <tags>
        <tag>Javascript</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NODE 学习0]]></title>
    <url>%2F2015%2F11%2F07%2Flearning%2Ffront-end%2Fnode%2Fstart-my-first-node-app%2F</url>
    <content type="text"><![CDATA[1.首先新建一个NODE项目2.可以使用命令行命令创建文件夹1mkdir views public 3.新建app.js 作为NODE项目起始文件 4.使用npm安装需要用到的module, 例如express, jade 等1npm install express jade 5.编写app.js文件1234567891011121314151617181920212223242526var express = require(&apos;express&apos;);var path = require(&apos;path&apos;);var bodyParser = require(&apos;body-parser&apos;);var port = process.env.PORT || 3000;var app = express();app.set(&apos;views&apos;, &apos;./views&apos;);app.set(&apos;view engine&apos;, &apos;jade&apos;);app.use(bodyParser.urlencoded(&#123; extended : true&#125;));app.use(bodyParser.json());app.use(express.static(path.join(__dirname, &apos;/public&apos;)));app.listen(port);console.log(&apos;the website starts on port &apos; + port);app.get(&apos;/&apos;, function (req, res) &#123; res.render(&apos;index&apos;);&#125;); 6.编写index.jade文件123456789doctypehtml head title hello node link(rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;) body h1 Hello Node 2015年11月07日10:40:31 script(src=&quot;scripts/index.js&quot;) 7.运行项目1node app.js]]></content>
      <tags>
        <tag>Javascript</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下一阶段学习目标]]></title>
    <url>%2F2015%2F06%2F30%2Flife%2F2016-06-30%2F</url>
    <content type="text"><![CDATA[现在是北京时间的2015年06月30日22:58:45，已经上班一个礼拜了。 今天是2015年上半年的最后一天，今天过了，就跨入到了2015年的下半年了，想想还是蛮难过的，时间过那么快，一点心理准备都没有T T 话说，第一个礼拜上班好不习惯，各种各种，同时来上海之前荒淫了两天导致又上火了。现在不知道为什么，一上火舌头就出问题，哎，各种难受，加上各种不习惯，还好坚持了过来。 然后，买了个13.3的mac pro，人生第一次拥有这么贵的东西，之前也考虑了很久，其实还不是因为穷么？买了这个在经济范围内的最贵的玩具，你不会后悔的。 也看了网上他们说购物的一些心得等等，买一个东西值不值就看你每天使用它的时间久不久。所以，买那些经常使用到的东西你可以大大的提高你的生活质量。 这一个礼拜，从刚开始的H5分享页面，到现在的shiqing.me的官网，感觉这样的创业团队还是比较赶的，每天都一直在忙。相对于恒天来讲，简直就是个灾难吧= = 而且我一般中午还睡不着觉，也不怎么休息，所以下午一般比较累。所以上火一周了还没有好，不过应该快好了把。 其实，来到十年后喜忧参半，忧是因为没有跟之前想象的那么好，虽然我也知道现实永远没有想象的那么美好，所以还是需要时间慢慢去接受这一切。好吧，其实是我还没做好一个人承担一切的准备，勇士是孤独的。喜是有了一个相对专业的team，和公司报销了mac的一办花费，想象还是蛮激动的。 今天忙完了之后，觉得心里还是有点小想法，就洗完澡码点字抒发下内心的情绪。最近还有好些事情，所以心头乱乱的，不愿意去想，也不愿意去做，只好拖着拖着等到再也拖不了去做。 觉得每天工作也算是种学习和成长，不过得多做总结和积累。 所以暂时定一下下一阶段的学习目标： 1、开发一个适应pc和mobile的动画框架2、学习Angular 或者 nodeJs说得多不如做得多，所以，加油吧，在这个那么多人都想往上爬的城市。 你是你自己人生的主角。 Face your fate。]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习（二） - CSS居中]]></title>
    <url>%2F2015%2F06%2F11%2Flearning%2Ffront-end%2Fcss%2Flearning-css-center-style%2F</url>
    <content type="text"><![CDATA[CSS居中一个img或者div元素总结。 1、水平居中一 text-align居中给父元素加添 text-align:center 即可。 适用于img等等，兼容IE8及以上，现代浏览器 2、水平居中二 margin居中给子元素添加 margin:0 auto即可。适用于img、div等等，兼容IE8及以上，现代浏览器 3、完全居中一 table-cell居中把父元素的display设置为:table-cell，把父元素的父元素的display设置为:table。同时把父元素设置为:text-align: center;vertical-align :middle; 即可。 适用于img等等，兼容IE8及以上，现代浏览器 12345678910111213141516&lt;div class=&quot;table&quot;&gt; &lt;div class=&quot;table-cell&quot;&gt; &lt;img src=&quot;demo.jpg&quot; &gt; &lt;/div&gt;&lt;/div&gt;.table &#123; width: 100%; height: 500px; display: table;&#125;.table-cell &#123; display: table-cell; text-align: center; vertical-align :middle;&#125; 4、完全居中二 absolute居中把父元素设置position属性为relative/absolute/fixed中任意一种。 把子元素设置position属性为absolute，并将四个方向距离值设为0，margin设为auto; 适用img、div等等，兼容IE8及以上，现代浏览器 1234567891011121314151617181920&lt;div class=&quot;layout&quot;&gt; &lt;img src=&quot;demo.jpg&quot; class=&quot;img&quot;&gt;&lt;/div&gt;.layout &#123; width: 100%; height: 300px; position:relative;&#125;.img &#123; width: 200px; height: 200px; background: red; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto;&#125; PS: 如果把上述子元素img的width和height属性删除的话，img会撑满整个父元素layout哦~ 5、完全居中三 translate居中把父元素设置position属性为relative/absolute/fixed中任意一种。把子元素设置position属性为absolute，距离left为50%，top为50%, 然后使用CSS3中的transform中translate移动属性，分别像X轴和Y轴平移-50%。(tips:距离left，top的百分比是针对父元素来说的，而transform的百分比是针对自身来说的。) 适用img、div等等，兼容IE9及以上，现代浏览器 12345678910111213141516171819&lt;div class=&quot;layout&quot;&gt; &lt;img src=&quot;demo.jpg&quot; class=&quot;img&quot;&gt;&lt;/div&gt;.layout &#123; width: 100%; height: 300px; position: relative;&#125;.img &#123; width: 200px; height: 200px; background: red; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);&#125; PS:如果知道子元素的width和height的具体属性时，可以在translate中写具体px数。或者去掉transform属性，改用margin-left:-100px和margin-top:-100px(上例中width和height各为200px)。 该方法兼容IE8; 6、完全居中四 Flexbox居中对Flexbox了解不是很多，感觉这个是个很神奇的属性，等到时候抽空需要好好补补。 使用Flexbox只需要给父元素加上下面这段就OK了。 123display: flex; justify-content: center; align-items: center; 适用img、div等等，不兼容IE = =，貌似只兼容现代浏览器 7、完全居中五 calc居中calc其实也相当于要知道width和height属性了。 把父元素设置position属性为relative/absolute/fixed中任意一种。把子元素设置position属性为absolute，距离left为 calc(50% - width / 2)，top为 calc( 50% - * height / 2)。(width, height 为代指); 适用img、div等等，兼容IE9及以上，现代浏览器 123456789101112131415161718&lt;div class=&quot;layout&quot;&gt; &lt;img src=&quot;demo.jpg&quot; class=&quot;img&quot;&gt;&lt;/div&gt;.layout &#123; width: 100%; height: 300px; position: relative;&#125;.img &#123; width: 200px; height: 200px; background: red; position: absolute; left: calc(50% - 100px); top: calc(50% - 100px);&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义组件三之画廊组件]]></title>
    <url>%2F2015%2F06%2F06%2Flearning%2Ffront-end%2Fplugins%2Fplugin-gallery%2F</url>
    <content type="text"><![CDATA[现在是北京时间的2015年6月6日22:37:32，耳边循环着的是douban的某个频道。 最近因为项目中需要用到一个画廊图片展示，就抽空写了个简易的画廊组件。 这次使用jquery作为基础类库，基于此开发的这个WEB组件。稍微做了些可以自定义的兼容，DEMO图片如下图。具体DEMO地址请猛击！ 该组件的大致开发思想为：用户传入画廊容器的ID，以及一些可选属性。然后根据元素填充大小，实现满容器的图片切换功能，之后根据容器中图片的数量创建包含等量数量的导航条，可以通过click 或 hover 事件触发手动切换画廊图片。以及添加了一个摧毁该画廊的方法。 首先定义一个构造函数，包括定义该gallery的version和author，以及一些默认的参数。包括动画持续时间，动画间隔（演示），父元素ID，手动切换方式。 123456789101112131415161718function BatmanGallery()&#123; this.version = &apos;1.0.0&apos;; this.author = &apos;tuzkiss&apos;; this.defalutConfig = &#123; // 动画持续时间 duration : 1000, // 动画延时 delay : 5000, // 相册容器ID parentId: &apos;body&apos;, // 切换方式click / hover eventStyle: &apos;click&apos; &#125;&#125; 然后在该构造函数的原型链上拓展方法： ··· # BatmanGallery.prototype = { 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164index : 0,length: 0,domId : &apos;body&apos;,liWidth : 0,delay : 5000,duration : 1000,animation : null,isStarted : false,isAnimation: false,eventStyle: &apos;clcik&apos;,init: function (config) &#123; // 混合参数 var CFG = $.extend(&#123;&#125;,this.defalutConfig, config); this.domId = CFG.parentId; this.duration = CFG.duration; this.delay = CFG.delay; this.eventStyle = CFG.eventStyle; this.initLayout().initLength().bindNavMove().bindGalleryMove(); return this;&#125;,// 初始化布局initLayout: function () &#123; var parentWidth = $(&apos;#&apos; + this.domId).width(), parentHeight = $(&apos;#&apos; + this.domId).height(); this.liWidth = parentWidth; $(&apos;#&apos; + this.domId).find(&apos;ul &gt; li &gt; img&apos;).css(&apos;height&apos;, parentHeight); return this;&#125;,// 初始化相册长度initLength:function () &#123; this.length = $(&apos;#&apos; + this.domId + &apos; &gt; ul&gt;li&apos;).length; if (this.length) &#123; this.createNav(this.domId); &#125; return this;&#125;,// 创建导航navcreateNav:function () &#123; $(&apos;#&apos; + this.domId + &apos;Nav&apos;).remove(); var nav = &apos;&apos;; nav += &apos;&lt;div id=&quot;&apos; + this.domId + &apos;Nav&quot; class=&quot;gallery-nav&quot;&gt;&lt;ul&gt;&apos;; nav += &apos;&lt;li class=&quot;active&quot;&gt;&apos; + 0 + &apos;&lt;/li&gt;&apos;; for (var i = 1; i &lt; this.length; i ++) &#123; nav += &apos;&lt;li&gt;&apos; + i + &apos;&lt;/li&gt;&apos;; &#125; nav += &apos;&lt;/ul&gt;&lt;/div&gt;&apos;; $(&apos;#&apos; + this.domId).find(&apos;ul&apos;).append(nav); return this;&#125;,// 绑定相册切换bindNavMove: function () &#123; var that = this; if (this.eventStyle === &apos;click&apos;) &#123; $(&apos;#&apos; + this.domId + &apos;Nav&apos;).find(&apos;li&apos;).unbind().click(function ()&#123; var $this = $(this); if (!$this.hasClass(&apos;active&apos;)) &#123; that.index = $this.html(); that.isStarted = false; that.bindGalleryMove(); &#125; &#125;); &#125; else if (this.eventStyle === &apos;hover&apos;) &#123; $(&apos;#&apos; + this.domId + &apos;Nav&apos;).find(&apos;li&apos;).unbind().hover(function ()&#123; var $this = $(this); if (!$this.hasClass(&apos;active&apos;)) &#123; that.index = $this.html(); that.isStarted = false; that.bindGalleryMove(); &#125; &#125;); &#125; return this;&#125;,// 绑定默认切换bindGalleryMove: function () &#123; var that = this; if (!this.isStarted) &#123; this.galleryMove(); this.isStarted = true; &#125; // 清除定时器 clearInterval(BATMAN_GALLERY_ANIMATION); BATMAN_GALLERY_ANIMATION = null; // 重置定时器 BATMAN_GALLERY_ANIMATION = setInterval(function ()&#123; that.galleryMove(); &#125;, this.delay);&#125;,// 相册切换方法galleryMove: function () &#123; if (this.isAnimation) &#123; return null; &#125; else &#123; var that = this, $nav = $(&apos;#&apos; + that.domId + &apos;Nav&gt;ul&apos;), marginLeft; this.isAnimation = true; if (this.index &lt;= this.length - 1) &#123; marginLeft = &apos;-&apos; + (this.index * this.liWidth) + &apos;px&apos;; &#125; else &#123; marginLeft = 0; &#125; $nav.find(&apos;.active&apos;).removeClass(&apos;active&apos;); $nav.find(&apos;li&apos;).eq(that.index).addClass(&apos;active&apos;); // 切换 $(&apos;#&apos; + this.domId + &apos;&gt;ul&apos;).animate(&#123; marginLeft:marginLeft &#125;, this.durations, function () &#123; that.isAnimation = false; if (that.index &lt; that.length - 1) &#123; that.index ++; &#125; else &#123; that.index = 0; &#125; &#125;); return this; &#125;&#125;,// 摧毁相册destroy: function () &#123; this.index = 0; this.isStarted = false; this.isAnimation = false; clearInterval(BATMAN_GALLERY_ANIMATION); BATMAN_GALLERY_ANIMATION = null; $(&apos;#&apos; + this.domId + &apos; &gt; ul&apos;).css(&apos;marginLeft&apos;, &apos;0&apos;); $(&apos;#&apos; + this.domId + &apos;Nav&apos;).remove(); return this;&#125; }··· 通过init函数初始化该gallery，需要传入自定义config对象，包含必须对象parentId（未判断，下次改进）。主要函数为：创建自动切换动画，和创建手动切换导航。 具体调用方法为: 123456new BatmanGallery().init(&#123; parentId: &apos;gallery&apos;, delay : 5000, duration : 1000, eventStyle: &apos;click&apos;&#125;); 具体DEMO地址请猛击！]]></content>
      <tags>
        <tag>Javascript</tag>
        <tag>Plugins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习（一）- 闭包]]></title>
    <url>%2F2015%2F05%2F28%2Flearning%2Ffront-end%2Fjavascripts%2Flearning-closure%2F</url>
    <content type="text"><![CDATA[对于自己前端基础的不扎实，决定花点时间去好好去学习或者先了解下比较薄弱的地方。 之前多次面试得出的结论是暂时有1、JS闭包2、JS事件3、JS一些其他基础知识等等4、CSS布局5、浏览器兼容性方面6、对于jq库，bootstrap库，以及js框架没有深层的去了解。 js闭包闭包是指有权访问另一个函数作用于内的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数 闭包有三个特性：1、函数嵌套函数2、函数内部可以引用外部的参数和变量3、参数和变量不会被垃圾回收机制回收，也就是说一直保存在内存中 例如: 12345678910function add()&#123; var index = 1; return function () &#123; index ++; &#125;&#125;var fn = add();fn(); // index : 1fn(); // index : 2fn = null; // fn被回收 闭包会是变量一直保存在内存中，所以如果使用不当的话就会增大内存消耗。 顺便说下javascript的垃圾回收机制：1、在javascript中，如果一个对象不再被引用吗，那么这个对象就会被GC回收。2、如果两个对象相互引用，而不再被第三者引用，那么这两个对象也会被回收。 那么闭包的好处在哪？1、可以让一个变量一直保存在内存中2、避免全局变量污染3、私有成员的存在 又例如： 123456789function add = (function ()&#123; var index = 1; return function ()&#123; index ++; &#125;&#125;)();add(); // index : 1add(); // index : 2 常用到的一个实例有，绑定点ul下的li元素然后显示对应li元素的内容。 12345678910111213141516171819202122232425// 假设有那么一个ul元素&lt;ul id=&quot;ul&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;ul&gt;// 那么在JS中绑定可以如下window.onload = function ()&#123; var ul = document.getElementById(&apos;ul&apos;); var li = ul.getElementsByTagName(&apos;li&apos;); for (var i = 0, len = li.length; i &lt; len; i ++) &#123; (function(i)&#123; li[i].addEventListener(&apos;click&apos;,alertLiHtml, false); &#125;)(i); &#125;&#125;function alertLiHtml()&#123; console.log(this); alert(this.innerHTML);&#125;]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义组件二之分页组件]]></title>
    <url>%2F2015%2F05%2F04%2Flearning%2Ffront-end%2Fplugins%2Fplugin-paging%2F</url>
    <content type="text"><![CDATA[现在是北京时间的2015年5月4日13:43:34，耳边听着的是shuffle中的歌曲。 刚准备把之前做的自定义组件总结一下，顺便解决了下之前没想清楚的小BUG，哈哈:joy: 因为之前在项目中需要用到分页组件，然后想到自己反正最近也在看一些关于开发自定义组件的知识，就想着要不自己尝试写一下咯，这样也能很好的适应项目的需求。然后。。就花了半天写了个差不多能用的分页组件。:joy: 分页组件大致思想为:传入一些跟生成分页有关的信息以及一个点击分页是的callback。因为之前做的是基于ajax的数据展现成table，所以分页变换也是在本页中展现，而不是通过页面挑战。 首先使用构造器函数定义一个分页函数: 1234567891011121314151617function Paging() &#123; this.version = &apos;1.1.4&apos;; this.author = &apos;TuzK1ss&apos;; this.config = &#123; pageSize: 10, pageIndex: 1, total: 10, parentId: &apos;document.body&apos;, align : &apos;right&apos;, callback: function (index) &#123; console.log(index); &#125; &#125; this.align = &apos;right&apos;;&#125;; 首先定义了版本号，作者以及对其方式，以及一个默认对象config。Config对象中包括需要传入的pageSize（每页数据条数），pageIndex（当前页），total（总条数），parentId（分页生成的父节点ID），align（对齐方式）， callback（点击每页触发回发事件）。 然后在构造器中拓展其prototype， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199Paging.prototype = &#123; init: function (config) &#123; var CFG = this.mixConfig(this.config, config); var domId = CFG.parentId, size = CFG.pageSize, index = CFG.pageIndex, total = CFG.total, callback = CFG.callback; this.align = CFG.align; this.renderPaging(domId, size, index, total, callback) .pagingClickHandler(domId, size, total, callback) .formSubmitHandler(domId, size, total, callback); return this; &#125;, mixConfig: function (defaultConfig, config) &#123; for (var i in defaultConfig) &#123; config[i] = config[i] || defaultConfig[i]; &#125; config.pageIndex = config.pageIndex &gt; Math.ceil(config.total / config.pageSize) ? Math.ceil(config.total / config.pageSize) : config.pageIndex; return config; &#125;, renderPaging: function (domId, size, index, total, callback) &#123; var dom = document.getElementById(domId), totalPage = Math.ceil(total / size), last = 0, html = &apos;&apos;; dom.innerHTML = &quot;&quot;; html += &apos;&lt;ul class=&quot;paging-ul paging-&apos; + this.align + &apos;&quot;&gt;&apos;; html += &apos;&lt;li class=&quot;prev&quot;&gt;&lt;a data-size=&quot;prev&quot; href=&quot;javascript:;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt;&apos;; index = Math.ceil(index); if (totalPage &lt;= 7) &#123; // 当分页总页数小于7时全部显示 if (index &lt; 4 &amp;&amp; totalPage &lt; 5) &#123; last = totalPage; &#125; else if (index &lt; 4 &amp;&amp; totalPage &gt;= 5) &#123; last = 5; &#125; else if (index &lt; 5 &amp;&amp; totalPage &gt;= 6) &#123; last = 6; &#125; else &#123; last = 7; &#125; for (var i = 1; i &lt; last + 1; i++) &#123; html += &apos;&lt;li class=&quot;item&quot;&gt;&lt;a data-size=&quot;&apos; + i + &apos;&quot; href=&quot;javascript:;&quot;&gt;&apos; + i + &apos;&lt;/a&gt;&lt;/li&gt;&apos;; &#125; &#125; else if (totalPage &gt; 7 &amp;&amp; index &lt;= 5) &#123; last = index + 2 &lt; 5 ? 5 : index + 2; for (var i = 1; i &lt; last + 1; i++) &#123; html += &apos;&lt;li class=&quot;item&quot;&gt;&lt;a data-size=&quot;&apos; + i + &apos;&quot; href=&quot;javascript:;&quot;&gt;&apos; + i + &apos;&lt;/a&gt;&lt;/li&gt;&apos;; &#125; html += &apos;&lt;li class=&quot;item dot&quot;&gt;...&lt;/li&gt;&apos;; &#125; else if (totalPage &gt; 7 &amp;&amp; index &gt; 5) &#123; // 当前页大于第五页 // 前两页 + ... for (var i = 1; i &lt; 3; i++) &#123; html += &apos;&lt;li class=&quot;item&quot;&gt;&lt;a data-size=&quot;&apos; + i + &apos;&quot; href=&quot;javascript:;&quot;&gt;&apos; + i + &apos;&lt;/a&gt;&lt;/li&gt;&apos;; &#125; html += &apos;&lt;li class=&quot;item dot&quot;&gt;...&lt;/li&gt;&apos;; // 后五页 if (index + 2 &lt; totalPage) &#123; for (var i = index - 2; i &lt; index + 3; i++) &#123; html += &apos;&lt;li class=&quot;item&quot;&gt;&lt;a data-size=&quot;&apos; + i + &apos;&quot; href=&quot;javascript:;&quot;&gt;&apos; + i + &apos;&lt;/a&gt;&lt;/li&gt;&apos;; &#125; html += &apos;&lt;li class=&quot;item dot&quot;&gt;...&lt;/li&gt;&apos;; &#125; else &#123; for (var i = index - 2; i &lt; totalPage + 1; i++) &#123; html += &apos;&lt;li class=&quot;item&quot;&gt;&lt;a data-size=&quot;&apos; + i + &apos;&quot; href=&quot;javascript:;&quot;&gt;&apos; + i + &apos;&lt;/a&gt;&lt;/li&gt;&apos;; &#125; &#125; &#125; html += &apos;&lt;li class=&quot;next&quot;&gt;&lt;a data-size=&quot;next&quot; href=&quot;javascript:;&quot;&gt;下一页&lt;/a&gt;&lt;/li&gt;&apos;; html += &apos;&lt;li class=&quot;paging-total&quot;&gt;&apos;; html += (&apos;共&apos; + total + &apos;条数据，&apos; + &apos;&lt;span id=&quot;&apos; + domId + &apos;PageForm&quot; class=&quot;form&quot;&gt;总计&amp;nbsp;&lt;span id=&quot;&apos; + domId + &apos;Total&quot;&gt;&apos; + totalPage + &apos;&lt;/span&gt;&amp;nbsp;页, 到第&amp;nbsp;&lt;input id=&quot;&apos; + domId + &apos;Index&quot; type=&quot;number&quot; value=&quot;&apos; + index + &apos;&quot; min=&quot;1&quot; max=&quot;&apos; + totalPage + &apos;&quot; class=&quot;paging-index&quot; value=&quot;&apos; + index + &apos;&quot;&lt;/input&gt;&amp;nbsp;&lt;/div&gt;页 &apos; + &apos;&lt;input id=&quot;&apos; + domId + &apos;Comfirm&quot; class=&quot;go-paging&quot; type=&quot;submit&quot; value=&quot;确定&quot;&gt;&lt;/span&gt;&apos;); html += &apos;&lt;/li&gt;&lt;/ul&gt;&apos;; dom.innerHTML = html; this.readerActiveLi(domId, index, totalPage).formSubmitHandler(domId, size, total, callback); return this; &#125;, readerActiveLi: function (domId, index, totalPage) &#123; var item = document.querySelectorAll(&apos;#&apos; + domId + &apos; .item a&apos;), indexA, tmp, tpp; if (1 == index) &#123; tmp = document.querySelector(&apos;#&apos; + domId + &apos; .prev a&apos;); tmp.style.color = &quot;#999&quot;; tmp.setAttribute(&apos;disabled&apos;, &apos;true&apos;); &#125; if (totalPage == index) &#123; tmp = document.querySelector(&apos;#&apos; + domId + &apos; .next a&apos;); tmp.style.color = &quot;#999&quot;; tmp.setAttribute(&apos;disabled&apos;, &apos;true&apos;); &#125; for (var i = 0, len = item.length; i &lt; len; i++) &#123; var indexA = item[i].getAttribute(&apos;data-size&apos;) || 0; if (index == indexA) &#123; item[i].parentNode.className += &apos; active-li&apos;; item[i].setAttribute(&apos;disabled&apos;, &apos;true&apos;); return this; &#125; &#125; return this; &#125;, pagingClickHandler: function (domId, size, total, callback) &#123; var that = this; var paging = document.getElementById(domId); paging.addEventListener(&apos;click&apos;, function (e) &#123; e = e || window.event; var target = e.target || e.srcElement; var index = target.getAttribute(&apos;data-size&apos;), isDisabled = target.getAttribute(&apos;disabled&apos;), //total = document.getElementById(domId + &apos;Total&apos;).innerHTML, active = parseInt(document.querySelector(&apos;#&apos; + domId + &apos; .active-li a&apos;).getAttribute(&apos;data-size&apos;)); if (index &amp;&amp; !isDisabled) &#123; if (index === &apos;prev&apos;) &#123; that.renderPaging(domId, size, active - 1, total, callback); &#125; else if (index === &apos;next&apos;) &#123; that.renderPaging(domId, size, active + 1, total, callback); &#125; else &#123; that.renderPaging(domId, size, index, total, callback); &#125; that.clickHandlerCallback(domId, callback); &#125; &#125;, false); return this; &#125;, getIndex: function (domId) &#123; var index = parseInt(document.querySelector(&apos;#&apos; + domId + &apos; .active-li a&apos;).getAttribute(&apos;data-size&apos;)); return index; &#125;, clickHandlerCallback: function (domId, callback) &#123; var index = this.getIndex(domId); callback(index); &#125;, formSubmitHandler: function (domId, size, total, callback) &#123; var that = this, input = document.getElementById(domId + &apos;Comfirm&apos;);; input.addEventListener(&apos;click&apos;, function (e) &#123; e = e || window.event; e.preventDefault(); var totalPage = Math.ceil(total / size); var form = document.getElementById(domId + &apos;PageForm&apos;), index = parseInt(form.getElementsByTagName(&apos;input&apos;)[0].value), active = that.getIndex(domId); if (index !== active &amp;&amp; index &lt;= totalPage &amp;&amp; index &gt; 0) &#123; that.renderPaging(domId, size, index, total, callback) .clickHandlerCallback(domId, callback); &#125; else if (index !== active) &#123; form.getElementsByTagName(&apos;input&apos;)[0].value = 1; &#125; &#125;, false); return this; &#125;&#125;; 拓展为几个方法，分别为init（初始化函数）mixConfig（混合自定义config和默认config）renderPaging（渲染分页组件）readerActiveLi（激活当前页面的页码li）pagingClickHandler（点击页码触发事件，包括上、下一页等）getIndex（获取当前激活页码，暴露给外部可以使用）clickHandlerCallback（触发回发事件）formSubmitHandler（点击跳转确定按钮触发事件） 当然后期可能还会有一些其他的方法加入进来例如更改skin， 重新渲染reReader，摧毁destroy等等。 具体的调用函数为: 123456789new Paging().init(&#123; pageSize: 10, pageIndex: 1, total: 18, parentId: &apos;newsPaging&apos;, callback: function (index) &#123; alert(index); &#125; &#125;); 成功调用之后会出现: 具体DEMO请猛击！ 请勿吐槽文件命名，下次会注意哈:joy:]]></content>
      <tags>
        <tag>Javascript</tag>
        <tag>Plugins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构和算法（一）]]></title>
    <url>%2F2015%2F04%2F23%2Flearning%2Falgorithm%2Flearning-algroithm(1)%2F</url>
    <content type="text"><![CDATA[他们说数据结构和算法是程序猿进化成高级程序猿的一个重要指标。哈哈，当然也顺便为了最近的面试笔试啥的 = = 好吧，其实没有大公司要我T T 错过了太多秋季招聘的时机，只能在临近毕业之前的个把月在努力一把。毕竟世界那么大，谁都想出去看看。 好了，不说扯远了。 这两天开始复习排序算法了= = 哈哈，最基础的算法。说起来自己也参加过3届ACM，但是打代码这种事，从来没有比现在更有感觉，也许是做久了吧，养成一个习惯了。或者说是开始慢慢入门面向对象，慢慢喜欢上了打代码的感觉= = 这两天晚上回去复习了几个排序算法，今天先总结一下： 1. 冒泡排序 （bubble sort）冒泡排序是最简单也是最常用的排序算法，核心是两层for循环依次比较大小，时间负责度为O(n^2); 具体代码如下: 12345678910111213141516// bubble sort function // @param &#123;Array&#125; the arr var bubbleSort = function (arr) &#123; var tmp; for (var i = 0 , len = arr.length; i &lt; len; i ++) &#123; for (var j = i; j &lt; len; j ++) &#123; if (arr[i] &gt; arr[j]) &#123; tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp; &#125; &#125; &#125; return arr;&#125; 2. 选择排序 （selection sort）选择排序是每次去选择数组中最小或者最大的那个数字并交换， 核心也是两次for循环，第二次循环去寻找剩余中最小或最大的数字，记录下下标，交换，时间负责的O(n^2) 具体代码如下: 1234567891011121314151617181920// selection sort function // @param &#123;Array&#125; the arrvar selectionSort = function (arr) &#123; var min, last, tmp; for (var i = 0, len = arr.length; i &lt; len; i ++) &#123; min = arr[i]; for (j = i + 1; j &lt; len; j ++) &#123; if (arr[j] &lt; min) &#123; last = j; min = arr[j]; &#125; &#125; tmp = arr[last]; arr[last] = arr[i]; arr[i] = tmp; &#125; return arr;&#125; 3. 插入排序 （insertion sort）插入排序是选择小的元素插入到数组的最前面，剩下的依次向后移， 其核心也是两层循环，不过与上面的稍微有点区别，内层循环分别取寻找比当前记录下的数字小或大的，然后依次移动，最后把找到的数字插入到外层循环下标位置。时间负责度为O(n^2) 具体代码如下： 123456789101112131415161718// insertion srot function// @param &#123;Array&#125; the arrvar insertionSort = function (arr) &#123; var tmp, last; for (var i = 1, len = arr.length; i &lt; len; i ++) &#123; tmp = arr[i]; last = i; while (last &gt; 0 &amp;&amp; (arr[last - 1] &gt;= tmp)) &#123; arr[last] = arr[last - 1]; last --; &#125; arr[last] = tmp; &#125; return arr;&#125; 上述这三种算法都是稳定的算法，而且时间负责度均为O(n^2)，但是数据量越大的情况下，排序效率还是有区别的，插入排序 &gt; 选择排序 &gt; 冒泡排序啊哈，等把哈希排序，归并排序看完之后再总结下= = Good luck ~]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快排大坑]]></title>
    <url>%2F2015%2F04%2F22%2Flearning%2Falgorithm%2Fquick-sort-remind%2F</url>
    <content type="text"><![CDATA[啊= = 晚上本来准备复习回顾下排序算法的= =，然后又写了个快排，又掉坑里了。。。老是死循环= = 每次都是这样，这次要好好记住！！ 记得 for 循环要从 1 开始 T T， 切记切记！1234567891011121314151617181920var quickSort = function (arr) &#123; var len = arr.length, value = arr[0], left = [], right = []; if (0 === len) &#123; return arr; &#125; for (var i = 1; i &lt; len; i ++) &#123; if (arr[i] &lt; value) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat(value, quickSort(right)); &#125; 哎，学习不易，且学且珍惜= = 早点休息哈，good night~]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义组件一之打印输出]]></title>
    <url>%2F2015%2F04%2F16%2Flearning%2Ffront-end%2Fplugins%2Fplugin-custom-print%2F</url>
    <content type="text"><![CDATA[现在是北京时间2015年4月16日23:08:15，刚看完HGT打LGD的“世界大战”，好久没有这么惊心动魄了，虽然好久没有去关注了，但是每次这种时候都会由心底的发出感慨，还好自己坚持着某些事，好久了。 扯远了，话说，最近想着在重写自己的Web简历就开始构思一些新技术之类，so，今天抽空弄了下阿里妈妈的中文字体库和一个自定义组件打印输出。 大致思想是传入需要依次打印输出的DOM操作ID数组和一些参数，让函数去依次遍历DOM里面的HTML文字，并把它依次输出。 开始学习采用构造器函数写自定义组件。 1234567891011121314151617function TypeWrite (config) &#123; // 需要填写的id Array this.idArray = config.idArray || []; // 打印每个字符的时间 this.wirteTime = config.writeTime || 400; // 打印每个id延时时间 this.delay = config.delay || 1000; // 打印这个id完停止时间 this.stop = config.stop || 500; // 打印下个id暂停的时间 this.pause = config.pasue || 0;&#125;; 先定义一个构造器函数，可以传入的值为：DOM操作ID数组，打印每个字符的时间， 打印每个DOM的延时时间，打印每个DOM完之后停止时间，和暂停时间。 停止时间是指打印完该DOM的HTML内容之后，光标仍在闪烁， 暂停时间是指光标已经不闪烁，然后进入下个DOM的流程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 初始化 TypeWrite.prototype.init = function () &#123; if (this.idArray) &#123; this.write(this.idArray, 0); &#125; &#125;; // 打印函数 TypeWrite.prototype.write = function (idArray, index) &#123; var dom = document.getElementById(idArray[index]), words = dom.innerHTML, charArray = words.trim().split(&apos;&apos;), len = charArray.length, i = 0, writeInterval, writeTimeout, flash; var that = this; dom.innerHTML = &apos;&amp;nbsp;&apos;; dom.className = dom.className.replace(/hidden/, &apos;&apos;); if (!writeTimeout) &#123; dom.innerHTML += &apos;&lt;span class=&quot;flash&quot;&gt;&lt;/span&gt;&apos;; writeTimeout = setTimeout(function () &#123; that.playSound(); typeInterval = setInterval(function () &#123; flash = document.getElementsByClassName(&apos;flash&apos;)[0]; if (flash &amp;&amp; i &lt; len) &#123; flash.parentNode.removeChild(flash); dom.innerHTML += charArray[i] + &apos;&lt;span class=&quot;flash&quot;&gt;&lt;/span&gt;&apos;; i++; &#125; else if(flash &amp;&amp; i === len) &#123; //dom.innerHTML = dom.innerHTML.replace(/&amp;nbsp;/, &apos;&apos;); clearInterval(typeInterval); setTimeout(function () &#123; flash.parentNode.removeChild(flash); that.stopSound(); if (index &lt; idArray.length - 1) &#123; // 进行下一个 setTimeout(function ()&#123; that.write(idArray, index + 1); &#125;, that.pause); &#125; &#125;, that.stop); &#125; &#125;, that.wirteTime); &#125;, this.delay); &#125; &#125;; TypeWrite.prototype.playSound = function ()&#123; var sound = &apos;&lt;embed loop=&quot;true&quot; src=&quot;type.wav&quot; hidden=&quot;true&quot; type=&quot;video/quicktime&quot;&gt;&lt;/embed&gt;&apos; ; document.getElementById(&apos;sound&apos;).innerHTML = sound; &#125; TypeWrite.prototype.stopSound = function () &#123; document.getElementById(&apos;sound&apos;).innerHTML = &apos;&apos;; &#125; 然后再TypeWrite的原型上拓展几个方法，分别为：init的初始化函数，write的操作函数，和playSound开启打字声音和stopSound关闭打字声音几个方法。 主要调用如下： 123456789var typeWrite = new TypeWrite(&#123; idArray: arr, wirteTime: 400, stop: 500, delay: 1000, pause: 0 &#125;); typeWrite.init(); 可能还没考虑到其他的一些性能问题，或者一些没考虑周全的会在后期想到更新哈:) 具体Demo地址请点击!]]></content>
      <tags>
        <tag>Javascript</tag>
        <tag>Plugins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识JS中的prototype和constructor]]></title>
    <url>%2F2015%2F04%2F05%2Flearning%2Ffront-end%2Fjavascripts%2Flearning-prototype-and-constructor%2F</url>
    <content type="text"><![CDATA[原型-prototype prototype本质上还是一个javascript函数。 每个函数都有一个默认的prototype属性。 通过prototype可以拓展Javascript内建对象。 构造器-constructor constructor始终指向创建之前对象的构造（初始化）函数。 每一个函数都有一个默认的属性prototype，而这个prototype的constructor默认指向这个函数。 下面新建Person构造函数，第一个为覆盖其prototype。 1234567891011121314151617181920212223242526272829function Person (name) &#123; this.name = name;&#125;;Person.prototype = &#123; getName: function () &#123; return this.name; &#125;&#125;;/* 上面的方法等价于下面 Person.prototype = new Object(&#123;getName:function () &#123; return this.name; &#125;&#125;); */var tuzkiss = new Person(&apos;tuzkiss&apos;);tuzkiss.getName();tuzkiss.constructor === Person; // falsePserson.prototype.constructor === Person; // falsetuzkiss..constructor.prototype.constructor === Person; // false// 因为上面的代码prototype中是覆盖了Person的prototype属性， 而不是修改// 如需变成true则需要在创建tuzkiss实例是 把Person的constructor重置// Person.prototype.constructor = Person; 第二个为修改其prototype 12345678910111213141516function Person(name) &#123; this.name = name;&#125;Person.prototype.getName = function () &#123; return this.name;&#125;var tuzkiss = new Person(&apos;tuzkiss&apos;);tuzkiss.getName();tuzkiss.constructor === Person; // truePerson.prototype.constructor === Person; // truetuzkiss.constructor.prototype.constructor === Person; // true// 因为上面getName只是在Person的prototype中拓展的，只是修改，并未覆盖]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式 - 工厂模式]]></title>
    <url>%2F2015%2F03%2F31%2Flearning%2Fdesign-patterns%2Fsimple-factory-pattern%2F</url>
    <content type="text"><![CDATA[这两天在看Javascript面向对象编程第二版这本书，由于其中对象的继承太过复杂就留着一点点看，就先看了后面章节的设计模式。 工厂模式是指在不指定对象具体类型的情况下创建对象，由实现这个接口的类来决定实例化哪个对象。主要适用于有多个类似方法的，但不确定使用什么方法去实例化对象，可以方便使用。 例如，下面是JS的工厂模式Demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 设计模式之工厂模式var batman = &#123; dom: &#123;&#125;&#125;;batman.dom.Text = function (url) &#123; this.url = url; this.insert = function (where) &#123; var txt = document.createTextNode(this.url); where.appendChild(txt); &#125;;&#125;;batman.dom.Image = function (url) &#123; this.url = url; this.insert = function (where) &#123; var image = document.createElement(&apos;img&apos;); image.src = this.url; where.appendChild(image); &#125;;&#125;;batman.dom.Link = function (url) &#123; this.url = url; this.insert = function (where) &#123; var link = document.createElement(&apos;a&apos;); link.href = this.url; link.target = &apos;_blank&apos;; link.appendChild(document.createTextNode(this.url)); where.appendChild(link); &#125;;&#125;;var url = &apos;http://www.sure-photo.com/qunchang/images/busibg.jpg&apos;;// 普通的调用方法/*var o = new batman.dom.Text(url);o.insert(document.body);o = new batman.dom.Image(url);o.insert(document.body);o = new batman.dom.Link(url);o.insert(document.body);*/// 工厂模式batman.dom.factory = function (type, url) &#123; if (batman.dom[type]) &#123; return new batman.dom[type](url); &#125; else &#123; console.log(&apos;no type: &apos; + type + &apos;.&apos;); &#125;&#125;;var o = batman.dom.factory(&apos;Image&apos;, url);o.insert(document.body);]]></content>
      <tags>
        <tag>Javascript</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
</search>
